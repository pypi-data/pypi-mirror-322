import importlib.metadata
import pathlib
import sys

import art
import cyclopts
import fspathtree
import jinja2
import rich.console
from typing_extensions import Annotated, List

from compudoc import document
from compudoc.execution_engines import *
from compudoc.template_engines import *


__version__ = importlib.metadata.version("compudoc")

app = cyclopts.App(
    name="compudoc",
    usage="Usage: compudoc [OPTIONS} INPUT_FILE [OUTPUT_FILE]",
    version=__version__,
)


def detect_filetype(filename):
    filepath = pathlib.Path(filename)
    if filepath.suffix in [".cd", ".compudoc"]:
        filepath = pathlib.Path(filepath.stem)

    filetypes = {
        ".tex": "latex",
        ".md": "markdown",
        ".gnuplot": "gnuplot",
    }
    return filetypes.get(filepath.suffix, None)


comment_line_strs = {
    "latex": "%",
    "markdown": "[comment]: #",
    "gnuplot": "#",
}


@app.default
def main(
    input_file: pathlib.Path,
    output_file: pathlib.Path = None,
    /,
    filetype: str = None,
    strip_comment_blocks: bool = False,
    comment_line_str: str = None,
    python: str = sys.executable,
    extract_code: bool = False,
    quiet: bool = False
):
    """
    Compudoc lets you write python code in you documents to perform calculations and insert the results.
    It is very handy for creating technical write-ups that need to record/report the result of some numerical calculations.

    Parameters
    ----------

    output-file
        Output filename template. The output filename will be generated by
        rendering this template. Use --show-output-filename-render-context to see a
        list of variables available in the template.
    filetype
        Set input filetype.
    strip_comment_blocks
        Remove comment blocks from document when rendering.
    comment_line_str
        Specify the string that comment lines will begin with.
    python
        Specify interpreter to use for evaluating code blocks.
    extract-code
        Extract code into a separate file.
    quiet
        Don't print status info while rendering.
    """

    console = rich.console.Console(stderr=True, quiet=quiet)
    econsole = rich.console.Console(stderr=True, quiet=quiet)
    env = jinja2.Environment()
    if output_file is None:
        if input_file.suffix in [".cd", ".compudoc"]:
            output_file = pathlib.Path(input_file.stem)
        else:
            output_file = pathlib.Path(
                input_file.stem + "-rendered" + input_file.suffix
            )

    font = "poinson"
    banner = art.text2art(f"CompuDoc", font=font)
    console.print(banner)
    console.print(f"version: {__version__}\n\n")

    if filetype is None:
        filetype = detect_filetype(input_file)
    if filetype is None and comment_line_str is None:
        console.print(f"Could not determine filetype for {input_file}")
        return 1

    if filetype == "markdown":
        strip_comment_blocks = True
    if comment_line_str is None:
        comment_line_str = comment_line_strs[filetype]

    console.print(f"Detected filetype: {filetype}")
    console.print(f"Comment string: {comment_line_str}")

    console.print(f"Rendering document {input_file} -> {output_file}")
    input_text = input_file.read_text()

    doc = document.Document()
    doc.set_comment_block_parser(document.CodeBlockParser(comment_line_str=comment_line_str))
    doc.set_template_engine(Jinja2())
    doc.set_execution_engine(Python(python))
    doc.parse(input_text)

    if extract_code:
        code_file_path = pathlib.Path(str(input_file)+".code")
        if code_file_path.exists():
            econsole.print(f"[red]Error: {code_file_path} already exists. Will not overwrite.[/red]")
            return 2
        else:
            with code_file_path.open('w') as f:
                for i,block in doc.enumerate_code_blocks():
                    f.write(f"# BLOCK {i}\n")
                    f.write(document.extract_code(block.text, doc.comment_block_parser.comment_line_str))


    output_text = doc.render(strip_comment_blocks=strip_comment_blocks, quiet=quiet)

    output_file.write_text(output_text)


