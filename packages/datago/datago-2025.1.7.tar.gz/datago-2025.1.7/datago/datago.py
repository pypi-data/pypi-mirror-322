
# python wrapper for package datago/pkg within overall package datago
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg -author=Photoroom -email=team@photoroom.com -name=datago -vm=python3 -version=2025.1.7 .

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _datago
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from datago import datago
# and then refer to everything using datago. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for map map[string]datago.ImagePayload
class Map_string_datago_ImagePayload(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.Map_string_datago_ImagePayload_CTor()
			_datago.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_datago_ImagePayload.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_datago.Map_string_datago_ImagePayload_set(self.handle, k, v)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		s = 'datago.Map_string_datago_ImagePayload len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'datago.Map_string_datago_ImagePayload({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _datago.Map_string_datago_ImagePayload_len(self.handle)
	def __getitem__(self, key):
		return ImagePayload(handle=_datago.Map_string_datago_ImagePayload_elem(self.handle, key))
	def __setitem__(self, key, value):
		_datago.Map_string_datago_ImagePayload_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _datago.Map_string_datago_ImagePayload_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_datago.Map_string_datago_ImagePayload_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _datago.Map_string_datago_ImagePayload_contains(self.handle, key)

# Python type for map map[string]datago.LatentPayload
class Map_string_datago_LatentPayload(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.Map_string_datago_LatentPayload_CTor()
			_datago.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_datago_LatentPayload.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_datago.Map_string_datago_LatentPayload_set(self.handle, k, v)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		s = 'datago.Map_string_datago_LatentPayload len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'datago.Map_string_datago_LatentPayload({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _datago.Map_string_datago_LatentPayload_len(self.handle)
	def __getitem__(self, key):
		return LatentPayload(handle=_datago.Map_string_datago_LatentPayload_elem(self.handle, key))
	def __setitem__(self, key, value):
		_datago.Map_string_datago_LatentPayload_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _datago.Map_string_datago_LatentPayload_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_datago.Map_string_datago_LatentPayload_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _datago.Map_string_datago_LatentPayload_contains(self.handle, key)

# Python type for map map[string]interface{}
class Map_string_interface_(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.Map_string_interface__CTor()
			_datago.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_interface_.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_datago.Map_string_interface__set(self.handle, k, v)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		s = 'datago.Map_string_interface_ len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'datago.Map_string_interface_({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _datago.Map_string_interface__len(self.handle)
	def __getitem__(self, key):
		return _datago.Map_string_interface__elem(self.handle, key)
	def __setitem__(self, key, value):
		_datago.Map_string_interface__set(self.handle, key, value)
	def __delitem__(self, key):
		return _datago.Map_string_interface__delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_datago.Map_string_interface__keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _datago.Map_string_interface__contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---
SourceTypeDB = "DB"
SourceTypeFileSystem = "filesystem"


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---

# Python type for interface datago.Generator
class Generator(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = 0

# Python type for interface datago.SampleDataPointers
class SampleDataPointers(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = 0

# Python type for interface datago.Backend
class Backend(go.GoClass):
	"""The backend will be responsible for fetching the payloads and deserializing them\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = 0


# ---- Structs ---

# Python type for struct datago.DatagoClient
class DatagoClient(go.GoClass):
	"""DatagoClient is the main client structure, will be instantiated by the user\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_DatagoClient_CTor()
			_datago.IncRef(self.handle)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.DatagoClient{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.DatagoClient ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Start(self, goRun=False):
		"""Start() 
		
		Start the background downloads, make it ready to serve samples. Will grow the memory and CPU footprint
		"""
		_datago.datago_DatagoClient_Start(self.handle, goRun)
	def GetSample(self):
		"""GetSample() object
		
		Get a deserialized sample from the client
		"""
		return Sample(handle=_datago.datago_DatagoClient_GetSample(self.handle))
	def Stop(self, goRun=False):
		"""Stop() 
		
		Stop the background downloads, will clear the memory and CPU footprint
		"""
		_datago.datago_DatagoClient_Stop(self.handle, goRun)

# Python type for struct datago.DatagoConfig
class DatagoConfig(go.GoClass):
	"""DatagoConfig is the main configuration structure for the datago client\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_DatagoConfig_CTor()
			_datago.IncRef(self.handle)
			if  0 < len(args):
				self.SourceType = args[0]
			if "SourceType" in kwargs:
				self.SourceType = kwargs["SourceType"]
			if  2 < len(args):
				self.ImageConfig = args[2]
			if "ImageConfig" in kwargs:
				self.ImageConfig = kwargs["ImageConfig"]
			if  3 < len(args):
				self.PrefetchBufferSize = args[3]
			if "PrefetchBufferSize" in kwargs:
				self.PrefetchBufferSize = kwargs["PrefetchBufferSize"]
			if  4 < len(args):
				self.SamplesBufferSize = args[4]
			if "SamplesBufferSize" in kwargs:
				self.SamplesBufferSize = kwargs["SamplesBufferSize"]
			if  5 < len(args):
				self.Limit = args[5]
			if "Limit" in kwargs:
				self.Limit = kwargs["Limit"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.DatagoConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.DatagoConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def SourceType(self):
		return _datago.datago_DatagoConfig_SourceType_Get(self.handle)
	@SourceType.setter
	def SourceType(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_DatagoConfig_SourceType_Set(self.handle, value.handle)
		else:
			_datago.datago_DatagoConfig_SourceType_Set(self.handle, value)
	@property
	def ImageConfig(self):
		return ImageTransformConfig(handle=_datago.datago_DatagoConfig_ImageConfig_Get(self.handle))
	@ImageConfig.setter
	def ImageConfig(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_DatagoConfig_ImageConfig_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def PrefetchBufferSize(self):
		return _datago.datago_DatagoConfig_PrefetchBufferSize_Get(self.handle)
	@PrefetchBufferSize.setter
	def PrefetchBufferSize(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_DatagoConfig_PrefetchBufferSize_Set(self.handle, value.handle)
		else:
			_datago.datago_DatagoConfig_PrefetchBufferSize_Set(self.handle, value)
	@property
	def SamplesBufferSize(self):
		return _datago.datago_DatagoConfig_SamplesBufferSize_Get(self.handle)
	@SamplesBufferSize.setter
	def SamplesBufferSize(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_DatagoConfig_SamplesBufferSize_Set(self.handle, value.handle)
		else:
			_datago.datago_DatagoConfig_SamplesBufferSize_Set(self.handle, value)
	@property
	def Limit(self):
		return _datago.datago_DatagoConfig_Limit_Get(self.handle)
	@Limit.setter
	def Limit(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_DatagoConfig_Limit_Set(self.handle, value.handle)
		else:
			_datago.datago_DatagoConfig_Limit_Set(self.handle, value)

# Python type for struct datago.LatentPayload
class LatentPayload(go.GoClass):
	"""--- Sample data structures - these will be exposed to the Python world ---------------------------------------------------------------------------------------------------------------------------------------------------------------\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_LatentPayload_CTor()
			_datago.IncRef(self.handle)
			if  0 < len(args):
				self.Data = args[0]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
			if  1 < len(args):
				self.Len = args[1]
			if "Len" in kwargs:
				self.Len = kwargs["Len"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.LatentPayload{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.LatentPayload ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Data(self):
		return go.Slice_byte(handle=_datago.datago_LatentPayload_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_LatentPayload_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Len(self):
		return _datago.datago_LatentPayload_Len_Get(self.handle)
	@Len.setter
	def Len(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_LatentPayload_Len_Set(self.handle, value.handle)
		else:
			_datago.datago_LatentPayload_Len_Set(self.handle, value)

# Python type for struct datago.DataSourceConfig
class DataSourceConfig(go.GoClass):
	"""Nested configuration structures for the client\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_DataSourceConfig_CTor()
			_datago.IncRef(self.handle)
			if  0 < len(args):
				self.PageSize = args[0]
			if "PageSize" in kwargs:
				self.PageSize = kwargs["PageSize"]
			if  1 < len(args):
				self.Rank = args[1]
			if "Rank" in kwargs:
				self.Rank = kwargs["Rank"]
			if  2 < len(args):
				self.WorldSize = args[2]
			if "WorldSize" in kwargs:
				self.WorldSize = kwargs["WorldSize"]
			if  3 < len(args):
				self.Limit = args[3]
			if "Limit" in kwargs:
				self.Limit = kwargs["Limit"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.DataSourceConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.DataSourceConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def PageSize(self):
		return _datago.datago_DataSourceConfig_PageSize_Get(self.handle)
	@PageSize.setter
	def PageSize(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_DataSourceConfig_PageSize_Set(self.handle, value.handle)
		else:
			_datago.datago_DataSourceConfig_PageSize_Set(self.handle, value)
	@property
	def Rank(self):
		return _datago.datago_DataSourceConfig_Rank_Get(self.handle)
	@Rank.setter
	def Rank(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_DataSourceConfig_Rank_Set(self.handle, value.handle)
		else:
			_datago.datago_DataSourceConfig_Rank_Set(self.handle, value)
	@property
	def WorldSize(self):
		return _datago.datago_DataSourceConfig_WorldSize_Get(self.handle)
	@WorldSize.setter
	def WorldSize(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_DataSourceConfig_WorldSize_Set(self.handle, value.handle)
		else:
			_datago.datago_DataSourceConfig_WorldSize_Set(self.handle, value)
	@property
	def Limit(self):
		return _datago.datago_DataSourceConfig_Limit_Get(self.handle)
	@Limit.setter
	def Limit(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_DataSourceConfig_Limit_Set(self.handle, value.handle)
		else:
			_datago.datago_DataSourceConfig_Limit_Set(self.handle, value)

# Python type for struct datago.SourceFileSystemConfig
class SourceFileSystemConfig(DataSourceConfig):
	"""-- Define the front end goroutine ---------------------------------------------------------------------------------------------------------------------------------------------------------------\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_SourceFileSystemConfig_CTor()
			_datago.IncRef(self.handle)
			if  1 < len(args):
				self.RootPath = args[1]
			if "RootPath" in kwargs:
				self.RootPath = kwargs["RootPath"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.SourceFileSystemConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.SourceFileSystemConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def RootPath(self):
		return _datago.datago_SourceFileSystemConfig_RootPath_Get(self.handle)
	@RootPath.setter
	def RootPath(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceFileSystemConfig_RootPath_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceFileSystemConfig_RootPath_Set(self.handle, value)

# Python type for struct datago.ImagePayload
class ImagePayload(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_ImagePayload_CTor()
			_datago.IncRef(self.handle)
			if  0 < len(args):
				self.Data = args[0]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
			if  1 < len(args):
				self.OriginalHeight = args[1]
			if "OriginalHeight" in kwargs:
				self.OriginalHeight = kwargs["OriginalHeight"]
			if  2 < len(args):
				self.OriginalWidth = args[2]
			if "OriginalWidth" in kwargs:
				self.OriginalWidth = kwargs["OriginalWidth"]
			if  3 < len(args):
				self.Height = args[3]
			if "Height" in kwargs:
				self.Height = kwargs["Height"]
			if  4 < len(args):
				self.Width = args[4]
			if "Width" in kwargs:
				self.Width = kwargs["Width"]
			if  5 < len(args):
				self.Channels = args[5]
			if "Channels" in kwargs:
				self.Channels = kwargs["Channels"]
			if  6 < len(args):
				self.BitDepth = args[6]
			if "BitDepth" in kwargs:
				self.BitDepth = kwargs["BitDepth"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.ImagePayload{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.ImagePayload ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Data(self):
		return go.Slice_byte(handle=_datago.datago_ImagePayload_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImagePayload_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def OriginalHeight(self):
		return _datago.datago_ImagePayload_OriginalHeight_Get(self.handle)
	@OriginalHeight.setter
	def OriginalHeight(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImagePayload_OriginalHeight_Set(self.handle, value.handle)
		else:
			_datago.datago_ImagePayload_OriginalHeight_Set(self.handle, value)
	@property
	def OriginalWidth(self):
		return _datago.datago_ImagePayload_OriginalWidth_Get(self.handle)
	@OriginalWidth.setter
	def OriginalWidth(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImagePayload_OriginalWidth_Set(self.handle, value.handle)
		else:
			_datago.datago_ImagePayload_OriginalWidth_Set(self.handle, value)
	@property
	def Height(self):
		return _datago.datago_ImagePayload_Height_Get(self.handle)
	@Height.setter
	def Height(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImagePayload_Height_Set(self.handle, value.handle)
		else:
			_datago.datago_ImagePayload_Height_Set(self.handle, value)
	@property
	def Width(self):
		return _datago.datago_ImagePayload_Width_Get(self.handle)
	@Width.setter
	def Width(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImagePayload_Width_Set(self.handle, value.handle)
		else:
			_datago.datago_ImagePayload_Width_Set(self.handle, value)
	@property
	def Channels(self):
		return _datago.datago_ImagePayload_Channels_Get(self.handle)
	@Channels.setter
	def Channels(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImagePayload_Channels_Set(self.handle, value.handle)
		else:
			_datago.datago_ImagePayload_Channels_Set(self.handle, value)
	@property
	def BitDepth(self):
		return _datago.datago_ImagePayload_BitDepth_Get(self.handle)
	@BitDepth.setter
	def BitDepth(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImagePayload_BitDepth_Set(self.handle, value.handle)
		else:
			_datago.datago_ImagePayload_BitDepth_Set(self.handle, value)

# Python type for struct datago.ImageTransformConfig
class ImageTransformConfig(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_ImageTransformConfig_CTor()
			_datago.IncRef(self.handle)
			if  0 < len(args):
				self.CropAndResize = args[0]
			if "CropAndResize" in kwargs:
				self.CropAndResize = kwargs["CropAndResize"]
			if  1 < len(args):
				self.DefaultImageSize = args[1]
			if "DefaultImageSize" in kwargs:
				self.DefaultImageSize = kwargs["DefaultImageSize"]
			if  2 < len(args):
				self.DownsamplingRatio = args[2]
			if "DownsamplingRatio" in kwargs:
				self.DownsamplingRatio = kwargs["DownsamplingRatio"]
			if  3 < len(args):
				self.MinAspectRatio = args[3]
			if "MinAspectRatio" in kwargs:
				self.MinAspectRatio = kwargs["MinAspectRatio"]
			if  4 < len(args):
				self.MaxAspectRatio = args[4]
			if "MaxAspectRatio" in kwargs:
				self.MaxAspectRatio = kwargs["MaxAspectRatio"]
			if  5 < len(args):
				self.PreEncodeImages = args[5]
			if "PreEncodeImages" in kwargs:
				self.PreEncodeImages = kwargs["PreEncodeImages"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.ImageTransformConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.ImageTransformConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def CropAndResize(self):
		return _datago.datago_ImageTransformConfig_CropAndResize_Get(self.handle)
	@CropAndResize.setter
	def CropAndResize(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImageTransformConfig_CropAndResize_Set(self.handle, value.handle)
		else:
			_datago.datago_ImageTransformConfig_CropAndResize_Set(self.handle, value)
	@property
	def DefaultImageSize(self):
		return _datago.datago_ImageTransformConfig_DefaultImageSize_Get(self.handle)
	@DefaultImageSize.setter
	def DefaultImageSize(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImageTransformConfig_DefaultImageSize_Set(self.handle, value.handle)
		else:
			_datago.datago_ImageTransformConfig_DefaultImageSize_Set(self.handle, value)
	@property
	def DownsamplingRatio(self):
		return _datago.datago_ImageTransformConfig_DownsamplingRatio_Get(self.handle)
	@DownsamplingRatio.setter
	def DownsamplingRatio(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImageTransformConfig_DownsamplingRatio_Set(self.handle, value.handle)
		else:
			_datago.datago_ImageTransformConfig_DownsamplingRatio_Set(self.handle, value)
	@property
	def MinAspectRatio(self):
		return _datago.datago_ImageTransformConfig_MinAspectRatio_Get(self.handle)
	@MinAspectRatio.setter
	def MinAspectRatio(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImageTransformConfig_MinAspectRatio_Set(self.handle, value.handle)
		else:
			_datago.datago_ImageTransformConfig_MinAspectRatio_Set(self.handle, value)
	@property
	def MaxAspectRatio(self):
		return _datago.datago_ImageTransformConfig_MaxAspectRatio_Get(self.handle)
	@MaxAspectRatio.setter
	def MaxAspectRatio(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImageTransformConfig_MaxAspectRatio_Set(self.handle, value.handle)
		else:
			_datago.datago_ImageTransformConfig_MaxAspectRatio_Set(self.handle, value)
	@property
	def PreEncodeImages(self):
		return _datago.datago_ImageTransformConfig_PreEncodeImages_Get(self.handle)
	@PreEncodeImages.setter
	def PreEncodeImages(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImageTransformConfig_PreEncodeImages_Set(self.handle, value.handle)
		else:
			_datago.datago_ImageTransformConfig_PreEncodeImages_Set(self.handle, value)

# Python type for struct datago.Pages
class Pages(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_Pages_CTor()
			_datago.IncRef(self.handle)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.Pages{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.Pages ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct datago.ARAwareTransform
class ARAwareTransform(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_ARAwareTransform_CTor()
			_datago.IncRef(self.handle)
			if  6 < len(args):
				self.PreEncodeImages = args[6]
			if "PreEncodeImages" in kwargs:
				self.PreEncodeImages = kwargs["PreEncodeImages"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.ARAwareTransform{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.ARAwareTransform ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def PreEncodeImages(self):
		return _datago.datago_ARAwareTransform_PreEncodeImages_Get(self.handle)
	@PreEncodeImages.setter
	def PreEncodeImages(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ARAwareTransform_PreEncodeImages_Set(self.handle, value.handle)
		else:
			_datago.datago_ARAwareTransform_PreEncodeImages_Set(self.handle, value)

# Python type for struct datago.BackendFileSystem
class BackendFileSystem(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_BackendFileSystem_CTor()
			_datago.IncRef(self.handle)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.BackendFileSystem{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.BackendFileSystem ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct datago.BackendHTTP
class BackendHTTP(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_BackendHTTP_CTor()
			_datago.IncRef(self.handle)
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.BackendHTTP{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.BackendHTTP ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct datago.ImageSize
class ImageSize(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_ImageSize_CTor()
			_datago.IncRef(self.handle)
			if  0 < len(args):
				self.Width = args[0]
			if "Width" in kwargs:
				self.Width = kwargs["Width"]
			if  1 < len(args):
				self.Height = args[1]
			if "Height" in kwargs:
				self.Height = kwargs["Height"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.ImageSize{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.ImageSize ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Width(self):
		"""Making it explicit how we store width and height, guarding against potential confusion
		"""
		return _datago.datago_ImageSize_Width_Get(self.handle)
	@Width.setter
	def Width(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImageSize_Width_Set(self.handle, value.handle)
		else:
			_datago.datago_ImageSize_Width_Set(self.handle, value)
	@property
	def Height(self):
		return _datago.datago_ImageSize_Height_Get(self.handle)
	@Height.setter
	def Height(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_ImageSize_Height_Set(self.handle, value.handle)
		else:
			_datago.datago_ImageSize_Height_Set(self.handle, value)
	def AspectRatio(self):
		"""AspectRatio() float"""
		return _datago.datago_ImageSize_AspectRatio(self.handle)

# Python type for struct datago.Sample
class Sample(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_Sample_CTor()
			_datago.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.Source = args[1]
			if "Source" in kwargs:
				self.Source = kwargs["Source"]
			if  2 < len(args):
				self.Attributes = args[2]
			if "Attributes" in kwargs:
				self.Attributes = kwargs["Attributes"]
			if  3 < len(args):
				self.DuplicateState = args[3]
			if "DuplicateState" in kwargs:
				self.DuplicateState = kwargs["DuplicateState"]
			if  4 < len(args):
				self.Image = args[4]
			if "Image" in kwargs:
				self.Image = kwargs["Image"]
			if  5 < len(args):
				self.Masks = args[5]
			if "Masks" in kwargs:
				self.Masks = kwargs["Masks"]
			if  6 < len(args):
				self.AdditionalImages = args[6]
			if "AdditionalImages" in kwargs:
				self.AdditionalImages = kwargs["AdditionalImages"]
			if  7 < len(args):
				self.Latents = args[7]
			if "Latents" in kwargs:
				self.Latents = kwargs["Latents"]
			if  8 < len(args):
				self.CocaEmbedding = args[8]
			if "CocaEmbedding" in kwargs:
				self.CocaEmbedding = kwargs["CocaEmbedding"]
			if  9 < len(args):
				self.Tags = args[9]
			if "Tags" in kwargs:
				self.Tags = kwargs["Tags"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.Sample{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.Sample ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ID(self):
		return _datago.datago_Sample_ID_Get(self.handle)
	@ID.setter
	def ID(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_ID_Set(self.handle, value.handle)
		else:
			_datago.datago_Sample_ID_Set(self.handle, value)
	@property
	def Source(self):
		return _datago.datago_Sample_Source_Get(self.handle)
	@Source.setter
	def Source(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_Source_Set(self.handle, value.handle)
		else:
			_datago.datago_Sample_Source_Set(self.handle, value)
	@property
	def Attributes(self):
		return Map_string_interface_(handle=_datago.datago_Sample_Attributes_Get(self.handle))
	@Attributes.setter
	def Attributes(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_Attributes_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def DuplicateState(self):
		return _datago.datago_Sample_DuplicateState_Get(self.handle)
	@DuplicateState.setter
	def DuplicateState(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_DuplicateState_Set(self.handle, value.handle)
		else:
			_datago.datago_Sample_DuplicateState_Set(self.handle, value)
	@property
	def Image(self):
		return ImagePayload(handle=_datago.datago_Sample_Image_Get(self.handle))
	@Image.setter
	def Image(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_Image_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Masks(self):
		return Map_string_datago_ImagePayload(handle=_datago.datago_Sample_Masks_Get(self.handle))
	@Masks.setter
	def Masks(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_Masks_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AdditionalImages(self):
		return Map_string_datago_ImagePayload(handle=_datago.datago_Sample_AdditionalImages_Get(self.handle))
	@AdditionalImages.setter
	def AdditionalImages(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_AdditionalImages_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Latents(self):
		return Map_string_datago_LatentPayload(handle=_datago.datago_Sample_Latents_Get(self.handle))
	@Latents.setter
	def Latents(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_Latents_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def CocaEmbedding(self):
		return go.Slice_float32(handle=_datago.datago_Sample_CocaEmbedding_Get(self.handle))
	@CocaEmbedding.setter
	def CocaEmbedding(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_CocaEmbedding_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Tags(self):
		return go.Slice_string(handle=_datago.datago_Sample_Tags_Get(self.handle))
	@Tags.setter
	def Tags(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_Sample_Tags_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct datago.SourceDBConfig
class SourceDBConfig(DataSourceConfig):
	"""-- Define the front end goroutine ---------------------------------------------------------------------------------------------------------------------------------------------------------------\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_datago.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_datago.IncRef(self.handle)
		else:
			self.handle = _datago.datago_SourceDBConfig_CTor()
			_datago.IncRef(self.handle)
			if  1 < len(args):
				self.Sources = args[1]
			if "Sources" in kwargs:
				self.Sources = kwargs["Sources"]
			if  2 < len(args):
				self.SourcesNE = args[2]
			if "SourcesNE" in kwargs:
				self.SourcesNE = kwargs["SourcesNE"]
			if  3 < len(args):
				self.RequireImages = args[3]
			if "RequireImages" in kwargs:
				self.RequireImages = kwargs["RequireImages"]
			if  4 < len(args):
				self.RequireEmbeddings = args[4]
			if "RequireEmbeddings" in kwargs:
				self.RequireEmbeddings = kwargs["RequireEmbeddings"]
			if  5 < len(args):
				self.Tags = args[5]
			if "Tags" in kwargs:
				self.Tags = kwargs["Tags"]
			if  6 < len(args):
				self.TagsNE = args[6]
			if "TagsNE" in kwargs:
				self.TagsNE = kwargs["TagsNE"]
			if  7 < len(args):
				self.HasAttributes = args[7]
			if "HasAttributes" in kwargs:
				self.HasAttributes = kwargs["HasAttributes"]
			if  8 < len(args):
				self.LacksAttributes = args[8]
			if "LacksAttributes" in kwargs:
				self.LacksAttributes = kwargs["LacksAttributes"]
			if  9 < len(args):
				self.HasMasks = args[9]
			if "HasMasks" in kwargs:
				self.HasMasks = kwargs["HasMasks"]
			if  10 < len(args):
				self.LacksMasks = args[10]
			if "LacksMasks" in kwargs:
				self.LacksMasks = kwargs["LacksMasks"]
			if  11 < len(args):
				self.HasLatents = args[11]
			if "HasLatents" in kwargs:
				self.HasLatents = kwargs["HasLatents"]
			if  12 < len(args):
				self.LacksLatents = args[12]
			if "LacksLatents" in kwargs:
				self.LacksLatents = kwargs["LacksLatents"]
			if  13 < len(args):
				self.ReturnLatents = args[13]
			if "ReturnLatents" in kwargs:
				self.ReturnLatents = kwargs["ReturnLatents"]
			if  14 < len(args):
				self.ReturnDuplicateState = args[14]
			if "ReturnDuplicateState" in kwargs:
				self.ReturnDuplicateState = kwargs["ReturnDuplicateState"]
			if  15 < len(args):
				self.MinShortEdge = args[15]
			if "MinShortEdge" in kwargs:
				self.MinShortEdge = kwargs["MinShortEdge"]
			if  16 < len(args):
				self.MaxShortEdge = args[16]
			if "MaxShortEdge" in kwargs:
				self.MaxShortEdge = kwargs["MaxShortEdge"]
			if  17 < len(args):
				self.MinPixelCount = args[17]
			if "MinPixelCount" in kwargs:
				self.MinPixelCount = kwargs["MinPixelCount"]
			if  18 < len(args):
				self.MaxPixelCount = args[18]
			if "MaxPixelCount" in kwargs:
				self.MaxPixelCount = kwargs["MaxPixelCount"]
			if  19 < len(args):
				self.DuplicateState = args[19]
			if "DuplicateState" in kwargs:
				self.DuplicateState = kwargs["DuplicateState"]
			if  20 < len(args):
				self.RandomSampling = args[20]
			if "RandomSampling" in kwargs:
				self.RandomSampling = kwargs["RandomSampling"]
	def __del__(self):
		_datago.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.SourceDBConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'datago.SourceDBConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Sources(self):
		return _datago.datago_SourceDBConfig_Sources_Get(self.handle)
	@Sources.setter
	def Sources(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_Sources_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_Sources_Set(self.handle, value)
	@property
	def SourcesNE(self):
		return _datago.datago_SourceDBConfig_SourcesNE_Get(self.handle)
	@SourcesNE.setter
	def SourcesNE(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_SourcesNE_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_SourcesNE_Set(self.handle, value)
	@property
	def RequireImages(self):
		return _datago.datago_SourceDBConfig_RequireImages_Get(self.handle)
	@RequireImages.setter
	def RequireImages(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_RequireImages_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_RequireImages_Set(self.handle, value)
	@property
	def RequireEmbeddings(self):
		return _datago.datago_SourceDBConfig_RequireEmbeddings_Get(self.handle)
	@RequireEmbeddings.setter
	def RequireEmbeddings(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_RequireEmbeddings_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_RequireEmbeddings_Set(self.handle, value)
	@property
	def Tags(self):
		return _datago.datago_SourceDBConfig_Tags_Get(self.handle)
	@Tags.setter
	def Tags(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_Tags_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_Tags_Set(self.handle, value)
	@property
	def TagsNE(self):
		return _datago.datago_SourceDBConfig_TagsNE_Get(self.handle)
	@TagsNE.setter
	def TagsNE(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_TagsNE_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_TagsNE_Set(self.handle, value)
	@property
	def HasAttributes(self):
		return _datago.datago_SourceDBConfig_HasAttributes_Get(self.handle)
	@HasAttributes.setter
	def HasAttributes(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_HasAttributes_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_HasAttributes_Set(self.handle, value)
	@property
	def LacksAttributes(self):
		return _datago.datago_SourceDBConfig_LacksAttributes_Get(self.handle)
	@LacksAttributes.setter
	def LacksAttributes(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_LacksAttributes_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_LacksAttributes_Set(self.handle, value)
	@property
	def HasMasks(self):
		return _datago.datago_SourceDBConfig_HasMasks_Get(self.handle)
	@HasMasks.setter
	def HasMasks(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_HasMasks_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_HasMasks_Set(self.handle, value)
	@property
	def LacksMasks(self):
		return _datago.datago_SourceDBConfig_LacksMasks_Get(self.handle)
	@LacksMasks.setter
	def LacksMasks(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_LacksMasks_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_LacksMasks_Set(self.handle, value)
	@property
	def HasLatents(self):
		return _datago.datago_SourceDBConfig_HasLatents_Get(self.handle)
	@HasLatents.setter
	def HasLatents(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_HasLatents_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_HasLatents_Set(self.handle, value)
	@property
	def LacksLatents(self):
		return _datago.datago_SourceDBConfig_LacksLatents_Get(self.handle)
	@LacksLatents.setter
	def LacksLatents(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_LacksLatents_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_LacksLatents_Set(self.handle, value)
	@property
	def ReturnLatents(self):
		return _datago.datago_SourceDBConfig_ReturnLatents_Get(self.handle)
	@ReturnLatents.setter
	def ReturnLatents(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_ReturnLatents_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_ReturnLatents_Set(self.handle, value)
	@property
	def ReturnDuplicateState(self):
		return _datago.datago_SourceDBConfig_ReturnDuplicateState_Get(self.handle)
	@ReturnDuplicateState.setter
	def ReturnDuplicateState(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_ReturnDuplicateState_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_ReturnDuplicateState_Set(self.handle, value)
	@property
	def MinShortEdge(self):
		return _datago.datago_SourceDBConfig_MinShortEdge_Get(self.handle)
	@MinShortEdge.setter
	def MinShortEdge(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_MinShortEdge_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_MinShortEdge_Set(self.handle, value)
	@property
	def MaxShortEdge(self):
		return _datago.datago_SourceDBConfig_MaxShortEdge_Get(self.handle)
	@MaxShortEdge.setter
	def MaxShortEdge(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_MaxShortEdge_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_MaxShortEdge_Set(self.handle, value)
	@property
	def MinPixelCount(self):
		return _datago.datago_SourceDBConfig_MinPixelCount_Get(self.handle)
	@MinPixelCount.setter
	def MinPixelCount(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_MinPixelCount_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_MinPixelCount_Set(self.handle, value)
	@property
	def MaxPixelCount(self):
		return _datago.datago_SourceDBConfig_MaxPixelCount_Get(self.handle)
	@MaxPixelCount.setter
	def MaxPixelCount(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_MaxPixelCount_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_MaxPixelCount_Set(self.handle, value)
	@property
	def DuplicateState(self):
		return _datago.datago_SourceDBConfig_DuplicateState_Get(self.handle)
	@DuplicateState.setter
	def DuplicateState(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_DuplicateState_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_DuplicateState_Set(self.handle, value)
	@property
	def RandomSampling(self):
		return _datago.datago_SourceDBConfig_RandomSampling_Get(self.handle)
	@RandomSampling.setter
	def RandomSampling(self, value):
		if isinstance(value, go.GoClass):
			_datago.datago_SourceDBConfig_RandomSampling_Set(self.handle, value.handle)
		else:
			_datago.datago_SourceDBConfig_RandomSampling_Set(self.handle, value)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def GetClient(config):
	"""GetClient(object config) object
	
	GetClient is a constructor for the DatagoClient, given a JSON configuration string
	"""
	return DatagoClient(handle=_datago.datago_GetClient(config.handle))
def GetClientFromJSON(jsonString):
	"""GetClientFromJSON(str jsonString) object"""
	return DatagoClient(handle=_datago.datago_GetClientFromJSON(jsonString))
def DatagoConfigFromJSON(jsonString):
	"""DatagoConfigFromJSON(str jsonString) object"""
	return DatagoConfig(handle=_datago.datago_DatagoConfigFromJSON(jsonString))
def GetDatagoConfig():
	"""GetDatagoConfig() object"""
	return DatagoConfig(handle=_datago.datago_GetDatagoConfig())
def GetSourceFileSystemConfig():
	"""GetSourceFileSystemConfig() object"""
	return SourceFileSystemConfig(handle=_datago.datago_GetSourceFileSystemConfig())
def GetSourceDBConfig():
	"""GetSourceDBConfig() object"""
	return SourceDBConfig(handle=_datago.datago_GetSourceDBConfig())


# ---- Functions ---


