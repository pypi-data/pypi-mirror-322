#! /usr/bin/python3

# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

import logging
from typing import Any, Dict, List
from sqlalchemy import log, exc, text
from sqlalchemy.dialects.mysql.mysqldb import MySQLDialect_mysqldb
from sqlalchemy.engine import Connection
from sqlalchemy.exc import OperationalError
from . import datatype
from sqlalchemy.sql import compiler

logger = logging.getLogger(__name__)


class DorisTypeCompiler(compiler.GenericTypeCompiler):
    def visit_DECIMAL(self, type_, **kw):
        return "DECIMAL"

    def visit_VARCHAR(self, type_, **kw):
        return "VARCHAR"

    def visit_CHAR(self, type_, **kw):
        return "CHAR"

    def visit_TEXT(self, type_, **kw):
        return "TEXT"

    def visit_DECIMAL(self, type_, **kw):
        return "DECIMAL"

    def visit_DOUBLE(self, type_, **kw):
        return "DOUBLE"

    def visit_FLOAT(self, type_, **kw):
        return "FLOAT"

    def visit_SMALLINT(self, type_, **kw):
        return "SMALLINT"

    def visit_TINYINT(self, type_, **kw):
        return "TINYINT"

    def visit_INTEGER(self, type_, **kw):
        return "INTEGER"

    def visit_BIGINT(self, type_, **kw):
        return "BIGINT"

    def visit_DATETIME(self, type_, **kw):
        if getattr(type_, "fsp", None):
            return "DATETIME(%d)" % type_.fsp
        else:
            return "DATETIME"

    def visit_DATE(self, type_, **kw):
        return "DATE"

    def visit_TIME(self, type_, **kw):
        if getattr(type_, "fsp", None):
            return "TIME(%d)" % type_.fsp
        else:
            return "TIME"

    def visit_TIMESTAMP(self, type_, **kw):
        if getattr(type_, "fsp", None):
            return "TIMESTAMP(%d)" % type_.fsp
        else:
            return "TIMESTAMP"

    def visit_ARRAY(self, type_, **kw):
        return "ARRAY"

    def visit_MAP(self, type_, **kw):
        return "MAP"

    def visit_STRUCT(self, type_, **kw):
        return "STRUCT"

    def visit_JSON(self, type_, **kw):
        return "JSON"

    def visit_BOOLEAN(self, type_, **kw):
        return "BOOL"

    def visit_LARGEINT(self, type_, **kw):
        return "LARGEINT"

    def visit_QUANTILE_STATE(self, type_, **kw):
        return "QUANTILE_STATE"

    def visit_AGG_STATE(self, type_, **kw):
        return "AGG_STATE"

    def visit_BITMAP(self, type_, **kw):
        return "BITMAP"

    def visit_HLL(self, type_, **kw):
        return "HLL"


@log.class_logger
class DorisDialect(MySQLDialect_mysqldb):
    # Caching
    # Warnings are generated by SQLAlchmey if this flag is not explicitly set
    # and tests are needed before being enabled
    supports_statement_cache = False
    type_compiler = DorisTypeCompiler
    name = 'workflow4ds_pydoris'

    def __init__(self, *args, **kw):
        super(DorisDialect, self).__init__(*args, **kw)

    def has_table(self, connection, table_name, schema=None, **kw):
        self._ensure_has_table_connection(connection)

        if schema is None:
            schema = self.default_schema_name

        assert schema is not None

        quote = self.identifier_preparer.quote_identifier
        full_name = quote(table_name)
        if schema:
            full_name = "{}.{}".format(quote(schema), full_name)

        try:
            res = connection.execute(text(f"DESCRIBE {full_name}"))  # 获取元数据信息
        except OperationalError as e:
            if "errCode = 2, detailMessage = Unknown table" in str(e):
                return False

            raise e

        return res.first() is not None

    def get_schema_names(self, connection, **kw):
        rp = connection.exec_driver_sql("SHOW schemas")  # 获取库名
        return [r[0] for r in rp]

    def get_table_names(self, connection, schema=None, **kw):  # 获取表名
        """Return a Unicode SHOW TABLES from a given schema."""
        if schema is not None:
            current_schema = schema
        else:
            current_schema = self.default_schema_name

        charset = self._connection_charset

        rp = connection.exec_driver_sql(
            "SHOW FULL TABLES FROM %s"
            % self.identifier_preparer.quote_identifier(current_schema)
        )

        return [
            row[0]
            for row in self._compat_fetchall(rp, charset=charset)
        ]

    def get_view_names(self, connection, schema=None, **kw):
        if schema is None:
            schema = self.default_schema_name
        charset = self._connection_charset
        rp = connection.exec_driver_sql(
            "SHOW FULL TABLES FROM %s"
            % self.identifier_preparer.quote_identifier(schema)
        )
        return [
            row[0]
            for row in self._compat_fetchall(rp, charset=charset)
            if row[1] in ("VIEW", "SYSTEM VIEW")
        ]

    def get_columns(self, connection: Connection, table_name: str, schema: str = None, **kw) -> List[Dict[str, Any]]:
        if not self.has_table(connection, table_name, schema):
            raise exc.NoSuchTableError(f"schema={schema}, table={table_name}")
        schema = schema or self._get_default_schema_name(connection)

        quote = self.identifier_preparer.quote_identifier
        full_name = quote(table_name)
        if schema:
            full_name = "{}.{}".format(quote(schema), full_name)

        res = connection.execute(text(f"SHOW COLUMNS FROM {full_name}"))
        columns = []
        for record in res:
            column = dict(
                name=record.Field,
                type=datatype.parse_sqltype(record.Type),
                nullable=record.Null == "YES",
                default=record.Default,
            )
            columns.append(column)
        return columns

    def get_pk_constraint(self, connection, table_name, schema=None, **kw):
        return {  # type: ignore  # pep-655 not supported
            "name": None,
            "constrained_columns": [],
        }

    def get_unique_constraints(
            self, connection: Connection, table_name: str, schema: str = None, **kw
    ) -> List[Dict[str, Any]]:
        return []

    def get_check_constraints(
            self, connection: Connection, table_name: str, schema: str = None, **kw
    ) -> List[Dict[str, Any]]:
        return []

    def get_foreign_keys(
            self, connection: Connection, table_name: str, schema: str = None, **kw
    ) -> List[Dict[str, Any]]:
        return []

    def get_primary_keys(self, connection: Connection, table_name: str, schema: str = None, **kw) -> List[str]:
        pk = self.get_pk_constraint(connection, table_name, schema)
        return pk.get("constrained_columns")  # type: ignore

    def get_indexes(self, connection, table_name, schema=None, **kw):
        return []

    def has_sequence(self, connection: Connection, sequence_name: str, schema: str = None, **kw) -> bool:
        return False

    def get_sequence_names(self, connection: Connection, schema: str = None, **kw) -> List[str]:
        return []

    def get_temp_view_names(self, connection: Connection, schema: str = None, **kw) -> List[str]:
        return []

    def get_temp_table_names(self, connection: Connection, schema: str = None, **kw) -> List[str]:
        return []

    def get_table_options(self, connection, table_name, schema=None, **kw):
        return {}

    def get_table_comment(self, connection: Connection, table_name: str, schema: str = None, **kw) -> Dict[str, Any]:
        return dict(text=None)
