"""Helper functions for Zernike polynomial generation... Could probably done more
easily with HCIPy
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.special import factorial


def read_haso_data(fn):
    """Returns wavefront data from the HASO WFS.
    
    Parameters
    ----------
    fn: str
        Path to a .txt file generated by the HASO WFS, which must be UTF-8 encoded.
    
    Returns
    -------
    out: nd_array of size
        The 2-dimensional wavefront data.
    """
    lines = open(fn, 'r').readlines()
    lines = lines[8:]  # skip header
    wfe = []
    for l in lines:
        l = l[:-1]  # remove newline
        wfe.append(l.split('\t'))
    wfe = np.array(wfe)
    wfe = np.where(wfe=='', np.nan, wfe)
    return wfe.astype(np.float64)


def poly_radial(m, n, rho):
    """Returns the radial part of the Zernike polynomial.
    
    Reference: Noll (1976).
    
    Parameters
    ----------
    m: int
        The azimuthal frequency as defined by Noll. Requires m <= n and n - abs(m)
        is even.
    n: int
        The radial degree as defined by Noll. Requires m <= n and n - abs(m) is
        even.
    rho: nd_array
        A 1D or 2D array of normalized radius rho in polar coordinates.
        
    Returns
    -------
    out: nd_array of shape rho.shape
        The polynomial evaluated for each value of rho. 
    """
    m = np.abs(m)
    s = np.arange(0, (n-m)/2 + 1, 1)
    # Argument of the sum for one value of s and rho
    arg = lambda s1, rho1: (-1)**s1 * factorial(n-s1) * rho1**(n-2*s1) \
                        / ( factorial(s1) * factorial((n+m)/2-s1)      \
                           * factorial((n-m)/2-s1) )
    # Compute the argument over every s and rho first, then collapse along the
    # appropriate dimension to get the sum. This is significantly faster than
    # iterating over the array and computing the sum for each value of rho.
    if len(rho.shape)==1:
        # 1D array of rho
        res = arg(s[None, :], rho[:, None])
        return np.sum(res, axis=1)
    else:
        # 2D array of rho
        sarr = np.ones(rho.shape + (len(s),))
        sarr[:,:] = s
        # force sarr and rho to have the same shape
        res = arg(sarr, rho[:,:,None])
        return np.sum(res, axis=-1)
    


def poly_angular(m, n, theta):
    """Returns the angular part of the Zernike polynomial. If m = 0, this function
    returns an array of constants.
    
    Reference: Noll (1976).
    
    Parameters
    ----------
    m: int
        The azimuthal frequency as defined by Noll. Requires m <= n and n - abs(m)
        is even.
    n: int
        The radial degree as defined by Noll. Requires m <= n and n - abs(m)
        is even.
    theta: nd_array
        A 1D or 2D array of angle theta in polar coordinates, in radians.
    
    Returns
    -------
    out: nd_array of shape theta.shape
        The polynomial evaluated for each value of theta. 
    """
    if m != 0:
        if m > 0:
            return np.sqrt(n + 1) * np.sqrt(2) * np.cos(m*theta)
        else:
            m = np.abs(m)
            return np.sqrt(n + 1) * np.sqrt(2) * np.sin(m*theta)
    # Make an array of constants for m = 0
    return np.ones(theta.shape) * np.sqrt(n + 1)


def noll_zernike_index(j):
    """Returns m and n from the Noll index j.
    
    Reference: Townson et al. (2019)
               AOtools v1.0.1
               https://github.com/AOtools/aotools
               
    Parameters
    ----------
    j: int
        The mode ordering number as defined by Noll.
    
    Returns
    -------
    m: int
        The azimuthal degree.
    n: int
        The radial degree.
    """
    # This is copied almost verbatim from AOtools's source code, specifically the
    # zernIndex function. See reference for more info.
    assert j > 0, "j must be greater than or equal to 1"
    assert int(j)==j, "j must be an integer"
    
    n = int((-1.+np.sqrt(8*(j-1)+1))/2.)
    p = (j-(n*(n+1))/2.)
    k = n%2
    m = int((p+k)/2.)*2 - k

    if m!=0:
        if j%2==0:
            s=1
        else:
            s=-1
        m *= s

    return [m, n]


def zernike_mn(m, n, rho, theta):
    """Returns a Zernike polynomial defined by m and n.
    
    Reference: Noll (1976).
    
    Parameters
    ----------
    m: int
        The azimuthal degree. m > 0 means that the polynomial is even, m < 0 for
        odd. Requires m <= n and n - abs(m) is even.
    n: int
        The radial degree. Requires m <= n and n - abs(m) is even.
    rho: nd_array
        A 1D or 2D array of normalized radius rho in polar coordinates. If 2D,
        the shape must be the same as theta.
    theta: nd_array
        A 1D or 2D array of angle theta in polar coordinates, in radians. If 2D,
        the shape must be the same as rho.
        
    Returns
    -------
    out: nd_array of size (rho.size, theta.size)
        The Zernike polynomial defined by m and n evaluated over the given values
        of rho and theta. If rho and theta are 1D, then the shape is (rho.size,
        theta.size). Otherwise, the shape is rho.shape.
    """
    assert m==int(m), "m must be an integer"
    assert n==int(n), "n must be an integer"
    assert m <= n, "m must be less than or equal to n"
    assert (n - np.abs(m)) % 2 == 0, "n - abs(m) must be even"

    # Multiply the angular part by the radial part. This requires an outer product
    # to get the desired 2-D array (every element in each array multiplied by
    # every other element)
    if (len(rho.shape)==1 and len(theta.shape)==1):
        return np.outer(poly_radial(m, n, rho), poly_angular(m, n, theta))
    else:
        return poly_radial(m, n, rho) * poly_angular(m, n, theta)


def noll_zernike_j(j, rho, theta):
    """Returns a Zernike polynomial defined by the Noll index j.
    
    Parameters
    ----------
    j: int
        The mode ordering number as defined by Noll.
    rho: nd_array
        A 1D or 2D array of normalized radius rho in polar coordinates. If 2D,
        the shape must be the same as theta.
    theta: nd_array
        A 1D or 2D array of angle theta in polar coordinates, in radians. If 2D,
        the shape must be the same as rho.
        
    Returns
    -------
    out: nd_array
        The Zernike polynomial defined by j evaluated over the given values of
        rho and theta. If rho and theta are 1D, then the shape is (rho.size, theta.size).
        Otherwise, the shape is rho.shape.
    """
    m, n = noll_zernike_index(j)
    return zernike_mn(m, n, rho, theta)


def generate_wfe(a_j, rho, theta):
    """Returns a wavefront composed of Zernike polynomials. The coefficients a_j
    define the shape of the wavefront.
    
    Parameters
    ----------
    a_j: nd_array
        An array containing the coefficients [a_1, a_2, ..., a_j] of the Zernike
        modes.
    rho: nd_array
        Normalized radius rho in polar coordinates.
    theta: nd_array
        Angle theta in polar coordinates, in radians.
    
    Returns
    -------
    out: nd_array of size (rho.size, theta.size)
        The wavefront error evaluated over the given values of rho and theta.
    """
    wfe = np.zeros((len(rho), len(theta)))
    for j in range(1, len(a_j)+1):
        # Noll index j starts at 1 but array indexing in Python starts at 0...
        wfe += a_j[j-1] * noll_zernike_j(j, rho, theta)
    return wfe


def generate_masked_wfe_cartesian(a_j, d_ap, x, y):
    """Returns the wavefront error over the pupil in microns.

    Parameters
    ----------
    a_j: nd_array
        An array containing the coefficients [a_1, a_2, ..., a_j] of the Zernike
        modes.
    d_ap: float
        Diameter of the aperture.
    x: nd_array
        x values to evaluate over in the same units as d_ap.
    y: nd_array
        y values to evaluate over in the same units as d_ap.
    
    Returns
    -------
    out: nd_array of size (x.size, y.size)
        The wavefront error in units of a_j.
    """
    r_ap = d_ap / 2
    # generate a grid of rho and theta from given x and y
    xx, yy = np.meshgrid(x, y)
    r = np.sqrt(xx**2 + yy**2)
    rho = r / r_ap
    # arctan2 instead of arctan to convert the angle depending on the quadrant
    theta = np.arctan2(yy, xx)
    wfe = generate_wfe(a_j, rho, theta)
    # mask out everything outside of the aperture
    mask = (x[np.newaxis,:])**2 + (y[:,np.newaxis])**2 > r_ap**2
    wfe[mask] = np.nan
    return wfe


def complex_pupil(wl, wfe, a_mask=None):
    """Returns the complex pupil function.
    
    Parameters
    ----------
    wl: float
        Wavelength in microns.
    wfe: nd_array
        The wavefront error over the pupil in microns.
    a_mask: None or nd_array
        Amplitude of the complex pupil function. This can be used as an apodization
        term.
    Returns
    -------
    out: nd_array of shape wfe.shape
        The complex pupil function.
    """
    k = 2*np.pi / wl
    cp = np.exp(1j * k * wfe)
    if a_mask is not None:
        return cp * a_mask
    else:
        # set to zero outside the aperture
        cp[np.isnan(wfe)] = 0
        return cp


def psf_from_cp(cp):
    """Returns the PSF from the complex pupil function.
    
    Parameters
    ----------
    cp: nd_array
        A 2-dimensional array containing the complex pupil function evaluated at
        different values of r and theta.
    
    Returns
    -------
    out: nd_array of shape cp.shape
        The PSF.
    """
    res = np.fft.ifftshift(cp)
    res = np.fft.fft2(res)
    res = np.fft.fftshift(res) 
    return np.abs(res)**2


def calc_normalized_psf(a_j, d_ap, wl, x, y):
    """Returns the PSF normalized to 1 at the maximum of the diffraction limit of
    the telescope.
    
    Parameters
    ----------
    a_j: nd_array
        An array containing the coefficients [a_1, a_2, ..., a_j] of the Zernike
        modes.
    d_ap: float
        Diameter of the aperture.
    x: nd_array
        x values to evaluate over in the same units as d_ap.
    y: nd_array
        y values to evaluate over in the same units as d_ap.
    
    Returns
    -------
    psf: nd_array
        The normalized PSF.
    wfe: nd_array
        The wavefront error computed from the Zernike coefficients.
    """
    wfe = generate_masked_wfe_cartesian(a_j, d_ap, x, y)
    psf = psf_from_cp(complex_pupil(wl, wfe))
    # Get diffraction-limited PSF with zero aberrations
    wfe_dl = generate_masked_wfe_cartesian(np.array([]), d_ap, x, y)
    psf_dl = psf_from_cp(complex_pupil(wl, wfe_dl))
    psf = psf/np.max(psf_dl)
    return psf, wfe


def find_first_minimum(psf_dl):
    """Returns the radius of the first minimum from the center.
    
    Parameters
    ---------
    psf_dl: nd_array
        A 2D array containing the Airy PSF.
    
    Returns
    -------
    out: int
        The radius in pixels.
    """
    a = np.sum(psf_dl, axis=0)
    # only look at values to the right of the center
    i0 = np.argmax(a)
    a = a[i0:]
    # iterate over the array until the next value is larger than the previous one
    i1 = 0
    while (i1 < len(a)):
        if a[i1] < a[i1+1]:
            return i1
        i1 += 1
    if i1==len(a):
        raise Exception('Could not find first minimum of Airy PSF.')


def calc_plate_scale(f_n, d_ap, wl, x, y):
    """Returns the pixel scale of the image plane.
    
    Parameters
    ----------
    f_n: float
        F-ratio of the telescope.
    d_ap: float
        Diameter of the aperture.
    wl: float
        Wavelength in microns.
    x: nd_array
        x values to evaluate over in the same units as d_ap.
    y: nd_array
        y values to evaluate over in the same units as d_ap.
        
    Returns
    -------
    out: float
        Image scale in microns per pixel.
    """
    wfe_dl = generate_masked_wfe_cartesian(np.array([]), d_ap, x, y)
    psf_dl = psf_from_cp(complex_pupil(wl, wfe_dl))
    # Radius of the first Airy minimum in microns
    r1 = 1.22 * wl * f_n
    x_scale = r1 / find_first_minimum(psf_dl)
    return x_scale


def create_zernike_matrix(k, n, eps=0.1):
    """Returns a matrix of Zernike polynomials masked to a circular pupil. The
    polynomials are evaluated over Cartesian coordinates.
    
    Parameters
    ----------
    k: int
        Number of Zernike modes.
    n: int
        Number of x-values to evaluate.
    eps: float, optional
        Ratio between the diameter of the central obscuration and the diameter
        of the pupil.
        
    Returns
    -------
    Z: nd_array of size (n, n, k)
        Zernike polynomials from j=1 to j=k+1 where j is the Noll Zernike index.
        For example, Z[:,:,3] gives focus.
    pupil_mask: nd_array of size (n, n)
        The masked region of the pupil.
    """
    # generate the matrix in Cartesian coordinates
    x = np.linspace(-1, 1, n)
    y = np.linspace(-1, 1, n)
    # generate a grid of rho and theta from given x and y
    xx, yy = np.meshgrid(x, y)
    rho = np.sqrt(xx**2 + yy**2)
    # arctan2 instead of arctan to convert the angle depending on the quadrant
    theta = np.arctan2(yy, xx)
    # mask the pupil including the central obscuration
    pupil_mask = np.logical_or((x[np.newaxis,:])**2 + (y[:,np.newaxis])**2 > 1, \
                               (x[np.newaxis,:])**2 + (y[:,np.newaxis])**2 < eps**2)
    Z = np.empty((k, n, n), dtype=np.float32)
    for i in range(k):
        zern_poly = noll_zernike_j(i+1, rho, theta)
        zern_poly[pupil_mask] = np.nan
        Z[i] = zern_poly
    Z = np.moveaxis(Z, 0, 2)
    return Z, pupil_mask


def zernike_to_actuator(a_z, F, plot_phi=False):
    """Returns the actuator commands for a set of Zernike coefficients.
    
    Parameters
    ----------
    a_z: array_like
        Noll Zernike coefficients: [piston, tip, tilt, focus, ...]
    F: nd_array of size (n x n x m)
        The influence functions where n is the length of the image data along 1
        axis (images are assumed to be square) and m is the number of actuators.
        
    Returns
    -------
    c: nd_array of size m
        Actuator commands.
    phi: nd_array of size (n, n)
        Input wavefront computed from zernike coefficients.
    """
    m = F.shape[-1]  # number of actuators
    n = F.shape[0]   # length of square data along 1 axis
    k = len(a_z)     # number of zernike coeffs
    
    Z, pupil_mask = create_zernike_matrix(k, n)
    phi = np.dot(Z, a_z)
    n_pup = np.count_nonzero(~np.isnan(phi))
    
    if plot_phi:
        plt.figure(figsize=(6,4))
        plt.imshow(phi)
        plt.colorbar()
        plt.title("Input Surface")
        plt.tight_layout()
        plt.show()

    Sigma = np.empty((m, m), np.float64)
    scalprod = np.empty(m, np.float64)
    for i in range(m):
        for j in range(i+1):
            # normalize by number of data points, which is n^2
            Sigma[i,j] = np.nansum(F[:,:,i] * F[:,:,j]) / n_pup
            Sigma[j,i] = Sigma[i,j]
        scalprod[i] = np.nansum(phi * F[:,:,i]) / n_pup
    Sigma_inv = np.linalg.pinv(Sigma)
    c = np.dot(scalprod, Sigma_inv)
    return c, phi


def zernike_projection(phi, k, eps=0.1):
    """Returns the projected Noll Zernike coefficients for a given wavefront.
    
    Parameters
    ----------
    phi: nd_array of size (n, n)
        The wavefront to project onto a Zernike basis.
    k: int
        The number of Zernike modes.
    eps: float, optional
        Ratio between the diameter of the central obscuration and the diameter
                of the pupil.
        
    Returns
    -------
    out: nd_array of size k
        Noll Zernike coefficients [a_1 (piston), a_2 (tip), a_3 (tilt), a_f (focus), ...].
    """
    phi = phi.copy()
    
    n = phi.shape[0]
    # Create the projection matrix
    Z, pupil_mask = create_zernike_matrix(k, n, eps=eps)
    Zp = np.reshape(Z, (n**2, k))
    Zp[np.isnan(Zp)] = 0
    arg1 = np.dot(Zp.T, Zp)
    arg2 = np.dot(np.linalg.pinv(arg1), Zp.T)
    # Multiply the wavefront by the projection matrix
    phip = np.reshape(phi, n**2)
    phip[np.isnan(phip)] = 0
    return np.dot(arg2, phip)