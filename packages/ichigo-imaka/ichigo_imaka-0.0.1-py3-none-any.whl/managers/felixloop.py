"""Class for closing the loop with FELIX.
NOTE: This package was never intended for real time control.
"""

import os
import numpy as np

from astropy.io import fits
from numpy.typing import NDArray, ArrayLike
from ichigo.strmanip import print_color, get_timestamp
from ichigo.servers import create_server, ImakaRTCServer, FELIXHelperServer
from ichigo.managers import Manager
from ichigo.config import SETTINGS

class FELIXLoopManager(Manager):
    """Recieves data from FELIX and sends commands to the RTC. This class is
    supposed to function as a "pseudo-RTC" for FELIX but is not designed to run
    in real time.

    Attributes
    ----------

    """
    def __init__(self, fn_cmat: str | None = None, rtc_alias: str = "rtc",
                 felix_alias: str = "felix") -> None:
        """Initializes the FELIXLoopManger object.

        Parameters
        ----------
        fn_cmat: str or None, optional

        Returns
        -------
        None
        """
        super().__init__()

        self.cmat: NDArray | None = None
        self.basis: str | None = None
        if fn_cmat:
            self.update_cmat(fn_cmat)

        # Zernike offsets
        self.offsets = np.array([0])
        # Previous command - set to 0 for now, but generally should be an nd_array
        self.a_prev = 0
        # Keep track of loop iteration
        self.loop_counter = 0
        
        # Add the relevant servers
        expected_types = {
            rtc_alias: ImakaRTCServer,
            felix_alias: FELIXHelperServer
            }

        for alias, server_type in expected_types.items():
            server = create_server(alias)
            assert isinstance(server, server_type), f"{alias} server must be of type {server_type}"
            self.add_server(alias, server)

        self.rtc: ImakaRTCServer = self.get_server(rtc_alias)
        self.felix: FELIXHelperServer = self.get_server(felix_alias)


    def _retrieve_stored_data(self, fname: str, ext: int = 0) -> tuple[NDArray, str]:
        """Attempts to retrieve a FITS file as either an absolute path or a file
        name in the FELIX data directory (defined in settings.ini). The data are
        retrieved from extension 0.

        Parameters
        ----------
        fname: str
            File name to retrieve.

        Returns
        -------
        data: nd_array
            Data from the FITS file. 
        path: str
            Absolute path to the file.
        """
        # Check if fname exists in the FELIX data directory. If not, try as
        # an absolute path.
        abs_path = os.path.join(SETTINGS["PATHS"]["felix"], fname)
        if not os.path.isfile(abs_path):
            print_color("This doesn't seem to exist in the FELIX resources directory. " \
                    + "Attempting to open as an absolute path: " + fname, "yellow")
            abs_path = fname
        # Try to load the file - it will fail here if the file doesn't exist.
        data = fits.getdata(abs_path, ext=ext)
        return data, abs_path

    def update_cmat(self, fname: str) -> None:
        """Updates the control matrix.

        Parameters
        ----------
        fn: str
            File name of the control matrix. Either an absolute path or a
            file in the FELIX data directory.

        Returns
        -------
        None
        """
        self.cmat, abs_path = self._retrieve_stored_data(fname, 0)
        # Update the modal basis
        hdr = fits.open(abs_path)[0].header
        self.basis = hdr["BASIS"]
    
    def change_basis(self, basis: str) -> None:
        """Changes the basis used for modal control.

        Parameters
        ----------
        basis: str
            Basis set of modes to use. Choose from one of the following:
                zernike: Noll Zernike polynomials, excluding piston.
                mirror: Mirror modes generated by Olivier Lai.

        Returns
        -------
        None
        """
        assert basis in ["zernike", "mirror"], "Modal basis not recognized"
        self.basis = basis
    
    def update_offsets(self, a: ArrayLike) -> None:
        """Updates modal offsets.
    
        Parameters
        ----------
        a: array_like
            Modal coefficients.
        """
        assert self.basis, "self.basis cannot be None"
        # Check that the number of modes is okay
        mode2act = self.rtc.get_projection_matrix(self.basis)
        n_modes = mode2act.shape[1]
        assert len(a) <= n_modes, "Number of coefficients must be less than or equal \
            to number of modes defined in conversion matrix (e.g., z2a)" 

        self.offsets = np.array(a)

    def make_imat_cmat_empirical(self, poke: float, n_modes: int, basis: str, update: bool = True, 
                                name_imat: str = "imat.felix", name_cmat: str = "cmat.felix") -> tuple[NDArray, NDArray]:
        """Creates a modal interaction matrix by injecting Zernikes onto the ASM
        and measuring the response of the WFS. Use :func:~`session.felixloop.FelixLoopManager.change_basis`
        to change the basis set of modes.

        Parameters
        ----------
        poke: float
            Poke command. Must be < 0.2 to avoid saturation.
        n_modes: int
            Number of modes.
        basis: str
            Basis set to use. Options: "zernike" or "mirror"
        update: bool
            If True, updates the cmat used for the control loop.
        fn_imat: str or None, optional
            File name to save the interaction matrix to. If None, does not save 
            the file.
        fn_cmat: str or None, optional
            File name to save the control matrix to. If None, does not save the
            file.
        
        Returns
        -------
        imat: nd_array
            Interaction matrix.
        cmat: nd_array
            Control matrix, which is the (pseudo-) inverse of the imat.
        """
        assert np.abs(poke) < 0.4, "Poke amount must be less than 0.4"

        # Loop must be open to project modes
        self.rtc.open_loop_noleak()

        # Construct the interaction matrix. Dimensions are determined by number
        # of modes and number of slopes (spots * 2).
        imat = np.zeros((2*SETTINGS["AO"]["n_subaps"], n_modes))#SETTINGS["FELIX"]["n_spots"]*2))
        for i in range(n_modes):
            print_color("Poking mode " + str(i), "cyan")
            a = np.zeros(n_modes)
            # Poke the actuators to put in the Zernike mode
            a[i] = poke
            self.rtc.project_modes(a, basis=basis, open=False)
            imat[:,i] = self.felix.get_slopes()
            # Poke the other way and repeat
            a[i] = -1*poke
            self.rtc.project_modes(a, basis=basis, open=False)
            imat[:,i] -= self.felix.get_slopes()
            # Normalize by the poke amount
            imat[:,i] /= 2*poke
        # Reset the DM to zero
        print_color("Reseting the actuators...", "cyan")
        self.rtc.poke_one_actuator(0, 0)
        
        cmat = np.linalg.pinv(imat)

        # Save the files
        date = get_timestamp(date_only=True)
        if name_imat:
            imat_path = os.path.join(SETTINGS["PATHS"]["felix"], name_imat + "." + date + ".fits")
            hdu = fits.PrimaryHDU(imat)
            hdu.header["UTCTIME"] = get_timestamp()
            hdu.header["BASIS"] = basis
            hdu.header["N_MODES"] = n_modes
            hdu.header["UNITS"] = "Phase / actuator command"
            hdu.header["COMMENT"] = "Interaction matrix for FELIX. Phase is differential \
                slope measurement / subaperture width."
            hdu.writeto(imat_path, overwrite=True)
        if name_cmat:
            cmat_path = os.path.join(SETTINGS["PATHS"]["felix"], name_cmat + "." + date + ".fits")
            hdu = fits.PrimaryHDU(cmat)
            hdu.header["UTCTIME"] = get_timestamp()
            hdu.header["BASIS"] = basis
            hdu.header["UNITS"] = "Inversion of imat - actuator command / phase"
            hdu.header["COMMENT"] = "Control matrix for FELIX"
            hdu.writeto(cmat_path, overwrite=True)
        
        if update:
            self.cmat = cmat
            self.basis = basis
        return cmat, imat
    
    def make_imat_cmat_theoretical(self, n_modes: int = 5, scale: float = 1,
                                   rotation: float = 0, signs: list[float] = []) -> tuple[NDArray, NDArray]:
        """Creates a theoretical modal interaction matrix for FELIX.

        Parameters
        ----------

        Returns
        ------
        """
        match self.basis:
            case "zernike":
                pass
            case "mirror":
                pass
            case _:
                raise ValueError("Not a valid basis set: " + str(self.basis)) 
        # Generate WFE over IRTF pupil

        # Transformation matrix to apply scale and rotation
        transform = np.array(
            [ [np.cos(rotation) , np.sin(rotation)],
            [-1*np.sin(rotation), np.cos(rotation)] ]
            ) * scale
        for i in range(n_modes):
            a = np.zeros(n_modes)
            pass

        # Compute average slope of WFE over subaperture locations
        raise NotImplementedError("This function is not yet implemented.")
        return (np.zeros(1), np.zeros(1))
    
    def _loop_iter(self, gain: float, leak: float) -> None:
        """Runs one iteration of the FELIX control loop.

        Parameters
        ----------
        gain: float
            Loop gain.
        leak: float
            Loop leak.

        Returns
        -------
        None
        """
        # Convert slopes to modes with cmat
        s = self.felix.get_slopes()
        # Leaky integrator
        a_now = np.dot(self.cmat, s)
        a = -1*gain*a_now + (1-leak)*self.a_prev
        self.a_prev = a
        # Send modes to RTC
        print_color("Settings modes: " + str(a), "cyan")
        self.rtc.project_modes(a, basis=self.basis, open=False)
        # Increment loop iteration
        self.loop_counter += 1
        
    def run_loop(self, gain: float, leak: float, n_iter: int = 1000000000) -> None:
        """Runs the loop for the specified number of iterations. This function runs
        one loop iteration and adds itself to the scheduler, allowing the loop to
        be run endlessly.

        Parameters
        ----------
        gain: float
            Loop gain.
        leak: float
            Loop leak.
        n_iter: int, optional
            Number of iterations. Set to 1 million iterations by default, so
            this function will essentially run endlessly.

        Returns
        -------
        None
        """
        assert 0 <= gain <= 1, "gain must be between 0 and 1"
        assert 0 <= leak <= 1, "leak must be between 0 and 1"
        assert self.cmat is not None, "Control matrix must be defined"

        # Make sure that the loop is open on the 'imaka RTC
        self.rtc.open_loop_noleak()
        # The timestep is defined by the frequency that FELIX outputs data
        for i in range(n_iter):
            self._loop_iter(gain, leak)
            if self.loop_counter % 10 == 0:
                print_color("FELIX loop iteration: " + str(self.loop_counter), "cyan")