# -*- coding: utf-8 -*-
# *******************************************************
#   ____                     _               _
#  / ___|___  _ __ ___   ___| |_   _ __ ___ | |
# | |   / _ \| '_ ` _ \ / _ \ __| | '_ ` _ \| |
# | |__| (_) | | | | | |  __/ |_ _| | | | | | |
#  \____\___/|_| |_| |_|\___|\__(_)_| |_| |_|_|
#
#  Sign up for free at https://www.comet.com
#  Copyright (C) 2015-2021 Comet ML INC
#  This source code is licensed under the MIT license.
# *******************************************************

# AUTOGENERATED: DO NOT EDIT THIS FILE

import json
import numbers
import tempfile
import zipfile
from collections import defaultdict

from comet_ml._typing import (
    IO,
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    List,
    Optional,
    Point3D,
    Set,
    TemporaryFilePath,
    Tuple,
    Union,
)
from comet_ml.annotations import Layer


def get_labels_from_annotations(annotations):
    labels = defaultdict(int)
    for layer in annotations:
        for item in layer["data"]:
            if item["label"]:
                labels[item["label"]] += 1
    return labels


class BaseType:
    def __init__(self, method_name, kwargs):
        self._method_name = method_name
        self._logged_result = None
        self._logged_experiment_key = None
        self._kwargs = kwargs

    def _log_result(self, result, experiment_key):
        self._logged_result = result
        self._logged_experiment_key = experiment_key

    def log(self, experiment):
        if experiment.id == self._logged_experiment_key:
            return self._logged_result
        else:
            result = getattr(experiment, self._method_name)(**self._kwargs)
            self._log_result(result, experiment.id)
            return result


class DataGrid(BaseType):
    count = 1

    def __init__(self, columns, data=None, name=None):
        """
        Create a datagrid containing data of values and
        assets.

        Args:
            columns: list of strings
            data: list of list of values
            name: the name of the datagrid
        """
        # Will set kwargs later
        super().__init__("_log_asset", {})

        self.columns = columns
        if name is None:
            self.name = "DataGrid-%s" % DataGrid.count
            DataGrid.count += 1
        else:
            self.name = name
        if data is not None:
            self.data = data
        else:
            self.data = []

    def append(self, row):
        """
        Append a row of values and assets.
        """
        self.data.append(row)

    def log(self, experiment):
        """
        Log the datagrid as a zipped JSON asset
        """
        # First, go though and get types:
        types = [None for column in self.columns]
        for r, row in enumerate(self.data):
            row_data = []
            if isinstance(row, dict):
                row = [row.get(column) for column in self.columns]
            for c, value in enumerate(row):
                if value is None:
                    # No evidence of type
                    continue
                elif isinstance(value, BaseType):
                    new_type = value.__class__.__name__.upper() + "-ASSET"
                else:
                    if isinstance(value, dict):
                        new_type = "JSON"
                    elif isinstance(value, str):
                        new_type = "TEXT"
                    elif isinstance(value, int):
                        new_type = "INTEGER"
                    elif isinstance(value, float):
                        new_type = "FLOAT"
                    elif isinstance(value, bool):
                        new_type = "BOOLEAN"
                    else:
                        # FIXME: add array
                        raise Exception("Unknown datatype: %r" % type(value))

                if types[c] is None:
                    types[c] = new_type
                elif type[c] in ["INTEGER", "FLOAT"] and new_type in [
                    "INTEGER",
                    "FLOAT",
                ]:
                    types[c] = "FLOAT"
                elif types[c] != new_type:
                    raise Exception(
                        "DataGrid %r, Row %d, column %d contains the wrong datatype: %r; should be %r"
                        % (self.name, r, c, new_type, types[c])
                    )

        # NOTE: If all items are None, then type of column is None

        # Now, we log the items, and the datagrid:
        results = []
        for r, row in enumerate(self.data):
            row_data = []
            if isinstance(row, dict):
                row = [row.get(column) for column in self.columns]
            for c, value in enumerate(row):
                if isinstance(value, BaseType):
                    asset_json = {}
                    result = value.log(experiment)
                    if "imageId" in result:
                        asset_json["asset_id"] = result["imageId"]
                    elif "assetId" in result:
                        asset_json["asset_id"] = result["assetId"]
                    else:
                        raise Exception("Logged results don't contain assetId")

                    for key in ["metadata", "annotations", "step", "epoch"]:
                        if key in value._kwargs and value._kwargs[key] is not None:
                            asset_json[key] = value._kwargs[key]
                            if key == "annotations":
                                labels = get_labels_from_annotations(asset_json[key])
                                if labels:
                                    asset_json["labels"] = labels
                    row_data.append(asset_json)
                else:
                    row_data.append(value)
            results.append(row_data)
        json_data = {
            "columns": {
                col_name: col_type for col_name, col_type in zip(self.columns, types)
            },
            "rows": results,
        }
        filename = "%s.json" % self.name
        with tempfile.NamedTemporaryFile(
            suffix=".json.zip",
            delete=False,
        ) as fp:
            with zipfile.ZipFile(fp, "w", zipfile.ZIP_DEFLATED) as zfp:
                zfp.writestr(filename, json.dumps(json_data))

        self._kwargs = {
            "file_data": fp.name,
            "file_name": filename + ".zip",
            "asset_type": "datagrid",
        }
        return super().log(experiment)


class Curve(BaseType):
    """Class for Experiment.log_curve()"""

    def __init__(
        self,
        name: str,
        x: Any,
        y: Any,
        overwrite: bool = False,
        step: Optional[int] = None,
    ):
        """
        Log timeseries data.

        Args:
            name: Name of data.
            x: list of x-axis values.
            y: list of y-axis values.
            overwrite: If True, overwrite previous log.
            step: The step value.

        Example:
            ```python linenums="1"
            import comet_ml

            comet_ml.login()
            exp = comet_ml.Experiment(project_name = "comet-docs")

            exp.log_curve("my curve", x=[1, 2, 3, 4, 5],
                                      y=[10, 20, 30, 40, 50])
            exp.end()
            ```
        """
        super().__init__(
            "log_curve",
            {
                "name": name,
                "x": x,
                "y": y,
                "overwrite": overwrite,
                "step": step,
            },
        )


class Asset(BaseType):
    """Class for Experiment.log_asset()"""

    def __init__(
        self,
        file_data: Any,
        file_name: Optional[str] = None,
        overwrite: bool = False,
        copy_to_tmp: bool = True,
        step: Optional[int] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ):
        """
        Logs the Asset determined by file_data.

        Args:
            file_data (Any): Either the file path of the file you want
                to log, or a file-like asset.
            file_name (str): A custom file name to be displayed. If not
                provided the filename from the `file_data` argument will be used.
            overwrite (bool): If True will overwrite all existing assets with the same name.
            copy_to_tmp (bool): (Deprecated) If `file_data` is a file-like object, then this flag determines
                if the file is first copied to a temporary file before upload. If
                `copy_to_tmp` is False, then it is sent directly to the cloud.
            step (int): Used to associate the asset to a specific step.
            metadata (Any): Some additional data to attach to the audio asset. Must be a
                JSON-encodable dict.

        Example:
            ```python linenums="1"
            import comet_ml
            import pandas as pd

            data = {
                'Name': ['Alice', 'Bob', 'Charlie', 'David'],
                'Age': [25, 30, 35, 40],
                'City': ['New York', 'Los Angeles', 'Chicago', 'Houston']
            }
            df = pd.DataFrame(data)
            df.to_csv('sample_data.csv', index=False)

            comet_ml.login()
            exp = comet_ml.Experiment(comet_project="comet-docs")

            exp.log_asset(file_data="sample_data.csv", file_name="sample_data.csv")

            exp.end()
            ```
        """
        super().__init__(
            "log_asset",
            {
                "file_data": file_data,
                "file_name": file_name,
                "overwrite": overwrite,
                "copy_to_tmp": copy_to_tmp,
                "step": step,
                "metadata": metadata,
            },
        )


class Audio(BaseType):
    """Class for Experiment.log_audio()"""

    def __init__(
        self,
        audio_data: Any,
        sample_rate: Optional[int] = None,
        normalize_data: str = "PCM_16_BIT",
        file_name: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
        overwrite: bool = False,
        copy_to_tmp: bool = True,
        step: Optional[int] = None,
    ):
        """
        Logs the audio Asset determined by audio data.

        Args:
            audio_data (str | numpy.array): Either the file path of the file you want
                to log, or a numpy array given to `scipy.io.wavfile.write` for wav conversion.
                Note that scipy assumes that stereo audio is in (n_samples, n_channels) order.
            sample_rate (int): The sampling rate given to
                `scipy.io.wavfile.write` for creating the wav file.
            normalize_data (str): The parameter that determines whether `audio_data` should be
                normalized to fit within the specific numerical bounds (e.g. 16-bit PCM).
                If you set this parameter to 'OFF', it is your responsibility to ensure
                that `audio_data` is compatible with the format supported by `scipy.io.wavfile.write`.
                Supported values: 'PCM_16_BIT', 'OFF'.
            file_name (str): A custom file name to be displayed.
                If not provided, the filename from the `audio_data` argument
                will be used.
            metadata (dict): Some additional data to attach to the audio asset.
                Must be a JSON-encodable dict.
            overwrite (bool): If True will overwrite all existing assets with the same name.
            copy_to_tmp (bool): (Deprecated) If `audio_data` is a numpy array, then this flag
                determines if the WAV file is first copied to a temporary file
                before upload. If `copy_to_tmp` is False, then it is sent
                directly to the cloud.
            step (int):  Used to associate the audio asset to a specific step.

        Note:
            See also [Log audio](/docs/v2/guides/experiment-management/log-data/audio/) and
            [Audio tab](/docs/v2/guides/comet-ui/experiment-management/single-experiment-page/#audio-tab).

        Example:
            ```python linenums="1"
            import comet_ml
            import numpy as np

            # Initialize Comet ML Experiment
            comet_ml.login()
            exp = comet_ml.Experiment(project_name = "comet-docs")

            # Create an audio sample
            fs = 100
            rate = 44100
            t = np.linspace(0., 1., rate)
            amplitude = np.iinfo(np.int16).max
            audio_sample = amplitude * np.sin(2. * np.pi * fs * t)

            # Log the audio to Comet ML
            exp.log_audio(
                audio_data=audio_sample,
                sample_rate=rate,
                file_name="Example Audio",
                step=0,
            )

            # End the experiment
            exp.end()
            ```
        """
        super().__init__(
            "log_audio",
            {
                "audio_data": audio_data,
                "sample_rate": sample_rate,
                "normalize_data": normalize_data,
                "file_name": file_name,
                "metadata": metadata,
                "overwrite": overwrite,
                "copy_to_tmp": copy_to_tmp,
                "step": step,
            },
        )


class Image(BaseType):
    """Class for Experiment.log_image()"""

    def __init__(
        self,
        image_data: Any,
        name: Optional[str] = None,
        overwrite: bool = False,
        image_format: str = "png",
        image_scale: float = 1.0,
        image_shape: Optional[Tuple[int, int]] = None,
        image_colormap: Optional[str] = None,
        image_minmax: Optional[Tuple[int, int]] = None,
        image_channels: str = "last",
        copy_to_tmp: bool = True,
        step: Optional[int] = None,
        annotations: Optional[List[Layer]] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ):
        """
        Logs the image. Images are displayed on the Graphics tab in Comet.

        Args:
            image_data (Any): Is one of the following:
                - a path (string) to an image
                - a file-like object containing an image
                - a numpy matrix
                - a TensorFlow tensor
                - a PyTorch tensor
                - a list or tuple of values
                - a PIL Image
            name (str): A custom name to be displayed on the dashboard.
                If not provided the filename from the `image_data` argument will be
                used if it is a path.
            overwrite (bool): If another image with
                the same name exists, it will be overwritten if overwrite is set to
                True.
            image_format (str): If the image_data is
                actually something that can be turned into an image, this is the
                format used. Typical values include 'png' and 'jpg'.
            image_scale (float): If the image_data is
                actually something that can be turned into an image, this will be the
                new scale of the image.
            image_shape (tuple): If the image_data is actually
                something that can be turned into an image, this is the new shape
                of the array. Dimensions are (width, height) or (width, height, colors)
                where `colors` is 3 (RGB) or 1 (grayscale).
            image_colormap (str): If the image_data is actually something
                that can be turned into an image, this is the colormap used to
                colorize the matrix.
            image_minmax (tuple): If the image_data is actually
                something that can be turned into an image, this is the (min, max)
                used to scale the values. Otherwise, the image is autoscaled between
                (array.min, array.max).
            image_channels (str): If the image_data is
                actually something that can be turned into an image, this is the
                setting that indicates where the color information is in the format
                of the 2D data. 'last' indicates that the data is in (rows, columns,
                channels) where 'first' indicates (channels, rows, columns).
            copy_to_tmp (bool): (Deprecated) If `image_data` is not a file path, then this flag determines
                if the image is first copied to a temporary file before upload. If
                `copy_to_tmp` is False, then it is sent directly to the cloud.
            step (int, optional): Used to associate the image asset to a specific step.
            annotations (list, optional): Annotations contains a list of annotation
                layers. Each annotation layer can contain bounding boxes and/or polygons. See
                example below.
            metadata (dict, optional): Additional metadata to be associated with logged image.
        Returns: None

        Example:
            ```python linenums="1"
            import comet_ml
            from comet_ml.annotations import Layer, Box, Polygon
            import numpy as np
            from PIL import Image

            comet_ml.login()
            exp = comet_ml.Experiment(project_name="comet-docs")


            # Create a dummy image using numpy
            width, height = 256, 256
            array = np.tile(np.linspace(0, 255, width, dtype=np.uint8), (height, 1))
            image = Image.fromarray(array)

            # Convert image to grayscale
            image = image.convert("L")

            # One layer with a box and polygon:
            annotations = [
                Layer(
                    boxes=[Box([x, y, w, h], label="dog")],
                    polygons=[Polygon([(x1, y1), ...], label="cat")],
                    name="Predictions",
                )
            ]

            # Log the image
            exp.log_image(
                image_data=image,
                name="Gradient.png",
                image_format="png",
                image_scale=0.5,
                image_shape=(128, 128),
                image_colormap='gray',
                step=1,
                annotations=annotations,
                metadata={"description": "A simple gradient image from black to white"}
            )

            # End the experiment
            exp.end()
            ```
        """
        super().__init__(
            "log_image",
            {
                "image_data": image_data,
                "name": name,
                "overwrite": overwrite,
                "image_format": image_format,
                "image_scale": image_scale,
                "image_shape": image_shape,
                "image_colormap": image_colormap,
                "image_minmax": image_minmax,
                "image_channels": image_channels,
                "copy_to_tmp": copy_to_tmp,
                "step": step,
                "annotations": annotations,
                "metadata": metadata,
            },
        )


class Video(BaseType):
    """Class for Experiment.log_video()"""

    def __init__(
        self,
        file: Union[str, IO],
        name: Optional[str] = None,
        overwrite: bool = False,
        format: Optional[str] = None,
        step: Optional[int] = None,
        epoch: Optional[int] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ):
        """
        Logs a video to Comet. Videos are displayed on the assets tab in Comet and support the
        following formats: MP4, MOV, WMV, and GIF.

        Args:
            file (str): The path to the video or a file-like object that contains the
                video.
            name (str): A custom name can be provided to be displayed on the assets
                tab. If not provided, the filename from the file argument will be used if it is a path.
            overwrite (bool): If another video with the same name exists, it will be
                overwritten if overwrite is set to True.
            format (str): The extension of the file is used to check if the asset is of a
                supported format. If the extension of the file is not correct or if you are uploading a
                file-like object, you can indicate the format of the video through this parameter.
            step (int): This is used to associate the video asset with a specific step.
            epoch (int): Used to associate the asset to a specific epoch.
            metadata (dict): additional custom metadata can be associated with the logged
                video.

        Example:
            ```python linenums="1"
            import comet_ml
            import cv2
            import numpy as np

            # Initialize Comet.ml
            comet_ml.init(project_name="comet-docs")
            exp = comet_ml.Experiment(project_name="comet-docs")

            # Create a dummy video file in MP4 format
            video_filename = 'output.mp4'
            frame_count = 60  # Number of frames in the video
            frame_width = 640
            frame_height = 480
            frame_rate = 10  # Frames per second

            fourcc = cv2.VideoWriter_fourcc(*'mp4v')
            out = cv2.VideoWriter(video_filename, fourcc, frame_rate, (frame_width, frame_height))

            for i in range(frame_count):
                frame = np.random.randint(0, 255, (frame_height, frame_width, 3), dtype=np.uint8)
                out.write(frame)

            out.release()

            # Log video file to Comet
            exp.log_video(video_filename, overwrite=True)

            # End the experiment
            exp.end()
            ```
        """
        super().__init__(
            "log_video",
            {
                "file": file,
                "name": name,
                "overwrite": overwrite,
                "format": format,
                "step": step,
                "epoch": epoch,
                "metadata": metadata,
            },
        )
