from dataclasses import dataclass, field
from datetime import date as _date
from datetime import datetime
from typing import Self

from dateutil.rrule import rrule

from budge.money import IntoMoney
from budge.rrule import rruleset

from . import account


@dataclass
class Transaction:
    """A single transaction record."""

    description: str
    amount: IntoMoney = IntoMoney()
    date: _date = field(default_factory=_date.today)
    account: "account.Account | None" = None
    parent: Self | None = None
    cleared: bool = False

    def __hash__(self):
        return hash((self.amount, self.description, self.date))

    def __lt__(self, other: Self):
        """Compare transactions based on their date for ordering."""
        return self.date < other.date


@dataclass(kw_only=True)
class RepeatingTransaction(Transaction):
    """
    A transaction that repeats on a schedule described by a
    `dateutil.rrule.rrule` or `dateutil.rrule.rruleset`.
    """

    schedule: rrule | rruleset
    _last_cleared: _date | None = None

    @property
    def last_cleared(self) -> _date | None:
        if self._last_cleared is None:
            return None

        return (
            self._last_cleared
            if isinstance(self._last_cleared, datetime)
            else datetime.combine(self._last_cleared, datetime.max.time())
        )

    @last_cleared.setter
    def last_cleared(self, date: _date | None):
        self._last_cleared = date

    def __hash__(self):
        return hash((self.amount, self.description, self.schedule))

    def __iter__(self):
        """
        Yield transactions generated by the repeat rule, each with the specified
        amount and description, and link them to this repeat transaction as
        their parent.
        """
        yield from (
            Transaction(
                amount=self.amount,
                description=self.description,
                date=next.date(),
                account=self.account,
                parent=self,
                cleared=(next <= self.last_cleared if self.last_cleared else False),
            )
            for next in self.schedule
        )
