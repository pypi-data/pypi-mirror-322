# -*- coding: utf-8 -*-
"""A StageData object acts like a data container that manages results generated by stages and read by subsequent
stages.

Depending on the stage, each class that inherits from StageData will contain different things, documented below.
Many of them will make use of pandas DataFrames to keep the data in a table-like shape.
"""

import heapq
from bisect import bisect_left
from collections import defaultdict

# from threading import Lock
from typing import Dict, List, Set


def bin_placement(query, bins):
    pos = bisect_left(bins, query)
    if pos == 0:
        return bins[0]
    if pos == len(bins):
        return bins[-1]
    before = bins[pos - 1]
    after = bins[pos]
    if after - query < query - before:
        return after
    else:
        return before


class StageData:
    """Any detection entry wether it is from GT or detections will be converted in this form."""

    def __init__(
        self,
        volume_id: str,
        label_name: str,
        class_name: str,
        roi_start: List[int],
        roi_shape: List[int],
        score: float = 1.0,
        subclass_name: str = None,
        **kwargs,
    ) -> None:
        self.volume_id = volume_id
        self.class_name = class_name
        self.score = score
        self.label_name = label_name
        self.roi_shape = roi_shape
        self.roi_start = roi_start
        if len(self.roi_start) == 2:
            self.roi_start.append(0)
            self.roi_shape.append(1)
        self.subclass_name = subclass_name or class_name

        self.blade_length = kwargs.get("blade_length", 0.0)

    def __eq__(self, other):
        return self.score == other.score

    def __lt__(self, other):
        return self.score > other.score  # reverted to make max heap instead of min heap later on

    def __str__(self) -> str:
        return f"StageData volume:{self.volume_id}, label{self.label_name}, category:{self.class_name}, confidence:{self.score} "


class ClassGroundTruthData:
    def __init__(self, single_data: StageData = None) -> None:
        self.vault = defaultdict(list)
        self.class_name: str = None
        self.sub_classes: Set[str] = set()
        self.subclass_stats = {}
        self._len = 0
        # self.mutex = Lock()
        if single_data:
            self.add(single_data)

    def add(self, single_data: StageData) -> None:
        # with self.mutex:
        if not self.class_name:
            self.class_name = single_data.class_name
        assert (
            self.class_name == single_data.class_name
        ), f"adding entry class {single_data.class_name} to list of {self.class_name}"
        self.vault[single_data.volume_id] += [single_data]
        self._len += 1
        self.sub_classes.add(single_data.subclass_name)
        self.subclass_stats[single_data.subclass_name] = self.subclass_stats.get(single_data.subclass_name, 0) + 1

    def __len__(self) -> int:
        return self._len

    def to_dict(self) -> Dict[str, List[StageData]]:
        return dict(self.vault)

    def __iter__(self):
        vault_copy = dict(self.vault)
        yield from vault_copy.items()


class ClassDetectionData:
    def __init__(self, single_data: StageData = None) -> None:
        self.vault = []
        self.class_name: str = None
        self.volume_ids = set()
        # self.mutex = Lock()
        if single_data:
            self.vault.append(single_data)
            self.class_name = single_data.class_name
            self.volume_ids.add(single_data.volume_id)

    def __str__(self) -> str:
        return f"Ground Truths for class: {self.class_name}"

    def __len__(self):
        return len(self.vault)

    def add(self, single_data: StageData) -> None:
        # with self.mutex:
        if not self.class_name:
            self.vault.append(single_data)
            self.class_name = single_data.class_name
            self.volume_ids.add(single_data.volume_id)
        assert (
            self.class_name == single_data.class_name
        ), f"adding entry class {single_data.class_name} to list of {self.class_name}"
        self.volume_ids.add(single_data.volume_id)
        heapq.heappush(self.vault, single_data)

    def __iter__(self) -> StageData:
        vault_copy = list(self.vault)
        while vault_copy:
            yield heapq.heappop(vault_copy)


class DatasetDetectionData:
    def __init__(self, single_data: StageData = None) -> None:
        self.vault: Dict[str, List[ClassDetectionData]] = {}
        if single_data:
            self.vault.add(single_data)

    def __str__(self) -> str:
        return f"Detection Dataset with classes: {list(self.vault.keys())}"

    def add(self, single_data: StageData) -> None:
        if single_data.class_name not in self.vault:
            self.vault[single_data.class_name] = ClassDetectionData(single_data)
        else:
            self.vault[single_data.class_name].add(single_data)

    def total_count(self):
        return sum(len(v_c) for v_c in self.vault.values())

    def generate_detection_iterables(self):
        return self.vault

    def detected_classes(self):
        return list(self.vault.keys())

    def subclass_mappings(self):
        return {k: v for k, cd in self.vault.items() for v in cd.subclass_names}

    def prune_dataset(self, volumes):
        pruned_dataset = {v: [] for v in volumes}
        for det_list in self.vault.values():
            # det_list_iter = iter(det_list)
            for det in iter(det_list):
                if det.volume_id in pruned_dataset:
                    pruned_dataset[det.volume_id].append(det)
        return pruned_dataset


class DatasetGroundTruthData:
    def __init__(self, single_data: StageData = None) -> None:
        self.vault = {}
        self.data_with_blade_length = []
        if single_data:
            self.vault[single_data.class_name] = ClassGroundTruthData(single_data)

    def __str__(self) -> str:
        return f"Ground Truth Dataset with classes: {list(self.vault.keys())}"

    def add(self, single_data: StageData) -> None:
        if single_data.class_name not in self.vault:
            self.vault[single_data.class_name] = ClassGroundTruthData(single_data)
        else:
            self.vault[single_data.class_name].add(single_data)

    def total_count(self):
        return sum(len(v_c) for v_c in self.vault.values())

    def generate_groundtruth_iterables(self):
        return self.vault

    def sub_classes(self):
        return {class_name: class_dataset.sub_classes for class_name, class_dataset in self.vault.items()}

    def subclass_stats(self):
        return {k: v.subclass_stats for k, v in self.vault.items()}

    def create_blade_length_dataset(self, length_value_list, classes):
        blade_length_dataset = {}
        # volumes = []
        for c, vols in self.vault.items():
            class_gt_data = {v: [] for v in length_value_list}
            if c in classes:
                class_gt_data = {v: [] for v in length_value_list}
                for d in vols.vault.values():
                    for gt in d:
                        if gt.blade_length and gt.blade_length > 0.0:
                            class_gt_data[bin_placement(gt.blade_length, length_value_list)].append(gt)
            blade_length_dataset[c] = class_gt_data
            # volumes.append(gt.volume_id)
        return blade_length_dataset  # , volumes


class SupportedDatasetSpecificationData:
    def __init__(self) -> None:
        self.ground_truths_dataset = DatasetGroundTruthData()
        self.detections_dataset = DatasetDetectionData()
        self.negatives_dataset = set()

    def __str__(self) -> str:
        gts = self.ground_truths_dataset.total_count() if self.ground_truths_dataset else 0
        dets = self.detections_dataset.total_count() if self.detections_dataset else 0
        return f"A dataset consisting of {dets} dets, {gts} gts and {len(self.negatives_dataset)} negative images."

    def add_ground_truth(self, single_datas: List[StageData]) -> None:
        for single_data in single_datas:
            self.ground_truths_dataset.add(single_data)

    def add_detection(self, single_datas: List[StageData]) -> None:
        for single_data in single_datas:
            self.detections_dataset.add(single_data)

    def add_negative(self, volume_id: str) -> None:
        self.negatives_dataset.add(volume_id)

    def pop_ground_truths(self):
        return self.ground_truths_dataset.generate_groundtruth_iterables()

    def pop_detections(self):
        return self.detections_dataset.generate_detection_iterables()

    def pop_negatives(self):
        return set(self.negatives_dataset)

    def sub_classes(self):
        return self.ground_truths_dataset.sub_classes()

    def detected_classes(self):
        return self.detections_dataset.detected_classes()

    def subclass_stats(self):
        return self.ground_truths_dataset.subclass_stats()

    def create_blade_length_dataset(self, length_value_list, classes):
        return self.ground_truths_dataset.create_blade_length_dataset(length_value_list, classes)
