from __future__ import annotations

import warnings
from logging import getLogger
from pathlib import Path

import pandas as pd
from copulas.multivariate import GaussianMultivariate

from synthius.data import ContinuousDataTransformer

logger = getLogger()


class GaussianMultivariateSynthesizer:
    """A class to generate synthetic data using the Gaussian Multivariate model.

    It includes encoding and decoding steps to handle categorical data and provides an option
    to adjust the distribution of a target column in the synthetic dataset to match that of the original dataset.

    Attributes:
        original_data (str | pd.DataFrame): Data as dataframe or Path to the original dataset file.
        output_path (pathlib.Path): Directory path where the synthesized dataset will be saved.
        data (pd.DataFrame): DataFrame containing the original dataset loaded from the specified file path.
    """

    def __init__(
        self: GaussianMultivariateSynthesizer,
        original_data: str | pd.DataFrame,
        output_path: str | Path | None = None,
    ) -> None:
        """Initializes the synthesizer with paths to the original data and output directory.

        Parameters:
            original_data (str | pd.DataFrame): Data as dataframe or Path to the original dataset file.
            output_path (str |Path): The directory path where the synthesized datasets will be saved.
        """
        if isinstance(original_data, str):
            self.original_data = Path(original_data)
            self.data = pd.read_csv(self.original_data, low_memory=False)
        else:
            self.data = original_data

        self.output_path = Path(output_path) if output_path else Path.cwd()

    def synthesize(
        self: GaussianMultivariateSynthesizer,
        num_sample: int | None = None,
        target_column: str | None = None,
        *,
        adjust_ratio: bool = False,
    ) -> None:
        """Generates and saves synthetic data using the Gaussian Multivariate model.

        It optionally adjusts the distribution of a specified target column in the synthetic data
        to match that of the original dataset.

        Parameters:
            num_sample (int | None): The number of samples to generate. Defaults to the number of rows in
                                     the original dataset if None.
            target_column (str | None): The column name for which to adjust the distribution in the synthetic data.
                                        Ignored if adjust_ratio is False.
            adjust_ratio (bool): Indicates whether to adjust the distribution of the target column in the synthetic data

        Returns:
            None
        """
        with warnings.catch_warnings():
            warnings.filterwarnings("ignore", category=RuntimeWarning)

            transformer = ContinuousDataTransformer(self.data)
            data_transformed = transformer.fit_transform()

            total_samples = num_sample if num_sample is not None else len(data_transformed)

            copula = GaussianMultivariate()
            synthetic_data = pd.DataFrame()
            batch_size = 500
            samples_generated = 0

            copula.fit(data_transformed)

            while samples_generated < total_samples:
                current_batch_size = min(batch_size, total_samples - samples_generated)
                synthetic_batch = copula.sample(current_batch_size)
                synthetic_data = pd.concat([synthetic_data, synthetic_batch], ignore_index=True)
                samples_generated += current_batch_size

            # Clip the synthetic data to ensure it remains within valid range
            for col in synthetic_data.columns:
                min_value = data_transformed[col].min()
                max_value = data_transformed[col].max()
                synthetic_data[col] = synthetic_data[col].clip(min_value, max_value)

            synthetic_data = transformer.inverse_transform(synthetic_data)

            if adjust_ratio and target_column:
                synthetic_data = self.adjust_ratio(synthetic_data, target_column)

            save_path = self.output_path / "GaussianMultivariate.csv"
            synthetic_data.to_csv(save_path, index=False)
            logger.info("Synthetic data saved to %s", save_path)

    def adjust_ratio(
        self: GaussianMultivariateSynthesizer,
        synthetic_data: pd.DataFrame,
        target_column: str,
    ) -> pd.DataFrame:
        """Adjusts the distribution of the specified target column in the synthetic data to match the original data.

        Parameters:
            synthetic_data (pd.DataFrame): The synthetic data generated by the model.
            target_column (str): The column name for which the distribution needs to be adjusted.

        Returns:
            pd.DataFrame: The synthetic data with adjusted distribution for the target column.
        """
        original_ratio = self.data[target_column].value_counts(normalize=True)

        num_samples_original = len(self.data)
        target_counts = {label: int(ratio * num_samples_original) for label, ratio in original_ratio.items()}

        adjusted_data = pd.DataFrame()
        for label, required_count in target_counts.items():
            subset = synthetic_data[synthetic_data[target_column] == label]
            if len(subset) > required_count:
                subset = subset.sample(n=required_count)
            adjusted_data = pd.concat([adjusted_data, subset])

        if len(adjusted_data) < num_samples_original:
            additional_samples_needed = num_samples_original - len(adjusted_data)
            additional_samples = synthetic_data.sample(n=additional_samples_needed)
            adjusted_data = pd.concat([adjusted_data, additional_samples], ignore_index=True)

        return adjusted_data
