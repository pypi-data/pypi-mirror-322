from _typeshed import Incomplete
from collections.abc import Iterable
from pandas import DataFrame
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.preprocessing import MinMaxScaler
from ydata.preprocessors.preprocess_methods import CategoricalEncoder, CategoricalImputer, DateTimeImputer, DateTimeTransformer, IdentityTransformer, IntegerTransformer

class TimeSeriesIdentity(BaseEstimator, TransformerMixin):
    def fit(self, X): ...
    def transform(self, X, y: Incomplete | None = None): ...
    def inverse_transform(self, X): ...

class TimeSeriesEquidistance(BaseEstimator, TransformerMixin):
    mode: Incomplete
    def fit(self, X): ...
    def transform(self, X, y: Incomplete | None = None): ...
    def inverse_transform(self, X): ...

class TimeSeriesOutlierDetector(BaseEstimator, TransformerMixin):
    outlier_frac: Incomplete
    def __init__(self, *, outlier_frac: float = 0.01) -> None: ...
    model: Incomplete
    def fit(self, X): ...
    def transform(self, X, y: Incomplete | None = None): ...
    def inverse_transform(self, X): ...

class TimeSeriesDetrend(BaseEstimator, TransformerMixin):
    cols_to_detrend: Incomplete
    trends: Incomplete
    def __init__(self, cols_to_detrend) -> None: ...
    def fit(self, X): ...
    def fit_column(self, X): ...
    def transform(self, X, y: Incomplete | None = None): ...
    def inverse_transform(self, X): ...

class TimeSeriesMinMaxScaler(MinMaxScaler):
    def transform(self, X, y: Incomplete | None = None): ...
    def inverse_transform(self, X): ...

class TimeSeriesIntegerTransformer(IntegerTransformer):
    def transform(self, X, y: Incomplete | None = None): ...
    def inverse_transform(self, X): ...

class TimeSeriesIdentityTransformer(IdentityTransformer):
    def transform(self, X, y: Incomplete | None = None): ...
    def inverse_transform(self, X): ...

class TimeSeriesCategoricalImputer(CategoricalImputer):
    def transform(self, X, y: Incomplete | None = None): ...
    def inverse_transform(self, X): ...

class TimeSeriesCategoricalEncoder(CategoricalEncoder):
    def transform(self, X, y: Incomplete | None = None): ...
    def inverse_transform(self, X): ...

class TimeSeriesDateTimeImputer(DateTimeImputer):
    def transform(self, X, y: Incomplete | None = None): ...
    def inverse_transform(self, X): ...

class TimeSeriesDateTimeTransformer(DateTimeTransformer):
    def transform(self, X, y: Incomplete | None = None): ...
    def inverse_transform(self, X): ...

class LambertWTransformer(BaseEstimator, TransformerMixin):
    delta: Incomplete
    def __init__(self, delta: float = 0.6) -> None: ...
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X): ...
    def inverse_transform(self, X): ...

class LogReturnsTransformer(BaseEstimator, TransformerMixin):
    def __init__(self) -> None: ...
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X): ...
    def inverse_transform(self, X, start: int = 0): ...

class ArcSinHTransformer(BaseEstimator, TransformerMixin):
    offset: Incomplete
    scale: Incomplete
    def __init__(self, offset, scale) -> None: ...
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X): ...
    def inverse_transform(self, X): ...

class AbsReturnsTransformer(BaseEstimator, TransformerMixin):
    def __init__(self) -> None: ...
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X: DataFrame): ...
    def inverse_transform(self, X: DataFrame, start: float = 0): ...

class RealToBinaryTransformer(BaseEstimator, TransformerMixin):
    max: Incomplete
    min: Incomplete
    n_digits: Incomplete
    def __init__(self) -> None: ...
    def fit(self, X, y: Incomplete | None = None, n_binary_digits: int = 16): ...
    def transform(self, X: DataFrame): ...
    def inverse_transform(self, X: DataFrame): ...

class NDiffTransformer(BaseEstimator, TransformerMixin):
    start: Incomplete
    def __init__(self) -> None: ...
    def fit(self, X: DataFrame, y: Incomplete | None = None): ...
    def transform(self, X: DataFrame, n_diff: int = 1): ...
    def inverse_transform(self, X, start: Iterable = None): ...
