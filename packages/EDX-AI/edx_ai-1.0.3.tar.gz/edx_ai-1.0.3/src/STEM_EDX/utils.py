#!/usr/bin/env python3
# -*- coding:utf-8 -*-

# MIT License

# Copyright (c) 2025 Anthony Pecquenard

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

## --------------------------------------------------------------------------------- ##
# This code provides an adaptation of the widgets and layouts offered by Pyside to
# make them more suitable for use with the with keyword. This allows for better
# structuring of the interface code and improved connectivity between widgets. 

# The modified widgets retain the names of the original widgets with the addition of 
# an "x_" prefix. Widgets can interact with each other through signals.

# Each widget or layout is defined with a key and a name attribute that can be used 
# to access the widget or layout in the parent widget. The key is generated by
# concatenating the parent key and the widget name.

# The widgets and layouts are defined as classes with __enter__ and __exit__ methods
# to allow the use of the "with" keyword. The __enter__ method returns the widget or
# layout object, and the __exit__ method is used to clean up the widget or layout.
## --------------------------------------------------------------------------------- ##

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas, NavigationToolbar2QT as NavigationToolbar

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QFrame, QPushButton, QSizePolicy, 
    QTabWidget, QMessageBox, QComboBox, QLineEdit, QTreeWidget, QTreeWidgetItem, 
    QMenu, QSpinBox
)
from PySide6.QtGui import QPixmap, QMouseEvent, QPainter, QColor, QPen
from PySide6.QtCore import Qt, QThread, Signal

# Import the colorscales module
try:
    import colorscales
except ImportError:
    import STEM_EDX.colorscales as colorscales

def show_message(title, message, type='error'):
    """
    Displays a message box with a specified title, message, and type.

    Parameters
    ----------
    title : str
        The title of the message box.
    message : str
        The content of the message to be displayed.
    type : str, optional
        The type of the message box, either 'error' or 'information'. 
        Modifies the icon displayed.
        Default is 'error'.

    Returns
    -------
    None
    """

    msg_box = QMessageBox()
    if type == 'error':
        msg_box.setIcon(QMessageBox.Critical)
    else:
        msg_box.setIcon(QMessageBox.Information)
    msg_box.setWindowTitle(title)
    msg_box.setText(message)
    msg_box.setStandardButtons(QMessageBox.Ok)
    msg_box.setStyleSheet("background-color: grey;")
    msg_box.exec()

class ObjectsManager:
    """
    A manager for handling objects with unique names.

    Attributes
    ----------
    objects : dict
        A dictionary storing objects with their names as keys.
    id : int
        An identifier for the number of objects added.

    Methods
    -------
    __getitem__(key)
        Retrieves an object by its name.
    add_object(obj)
        Adds a new object to the manager.
    """


    def __init__(self, parent):
        """
        Attributes
        ----------
        objects : dict
            A dictionary to store objects.
        id : int
            An identifier starting from 0.
        """

        self.objects = {}
        self.id = 0

    def __getitem__(self, key):
        """
        Retrieve an item from the objects dictionary using the given key.

        Parameters
        ----------
        key : hashable
            The key to access the corresponding value in the objects dictionary.

        Returns
        -------
        object
            The value associated with the given key in the objects dictionary.
        """

        return self.objects[key]

    def add_object(self, obj):
        """
        Adds an object to the collection.

        Parameters
        ----------
        obj : object
            The object to be added. It must have a 'name' attribute.

        Returns
        -------
        object
            The added object.

        Raises
        ------
        ValueError
            If an object with the same name already exists in the collection.
        """

        if obj.name in self.objects:
            raise ValueError(f"An object with the name {obj.name} already exists.")
        else:
            self.objects[obj.name] = obj
            self.id += 1
            return obj


class Worker(QThread):
    """
    A QThread subclass that performs actions on selected objects and emits 
    progress signals.

    Parameters
    ----------
    objects : dict
        A dictionary of objects on which actions will be performed.
    selected_objects : list
        A list of object names to be processed.
    action : str
        The action to be performed on the selected objects. Supported actions 
        are 'PCA' and 'NMF'.

    Attributes
    ----------
    progress : Signal
        Signal emitted to indicate progress as an integer percentage.
    errors : list
        A list of object names for which the action failed.

    Methods
    -------
    run()
        Executes the specified action on the selected objects and emits 
        progress signals.
    """

    progress = Signal(int)

    def __init__(self, objects, selected_objects, action):
        super().__init__()
        self.objects = objects
        self.selected_objects = selected_objects
        self.action = action
        self.errors = []

    def run(self):
        """
        Executes the specified action ('PCA' or 'NMF') on selected objects and 
        updates the progress.

        - The function iterates over the selected objects and applies the specified 
          action ('PCA' or 'NMF') to each object.
        - Progress is emitted as a percentage after processing each object.
        - If the action fails for any object, the object's name is appended to the 
          errors list.
        """

        total = len(self.selected_objects)
        for i, obj_name in enumerate(self.selected_objects):
            if self.action == 'PCA':
                success = self.objects[obj_name].apply_PCA()
            elif self.action == 'NMF':
                success = self.objects[obj_name].apply_NMF()
            self.progress.emit(int((i + 1) / total * 100))

            if success == 'Failed':
                self.errors.append(obj_name)


class CustomToolbar(NavigationToolbar):
    """
    A custom toolbar for a matplotlib canvas, removing unwanted buttons and 
    adding a spin box for selecting components.

    Parameters
    ----------
    canvas : FigureCanvas
        The matplotlib canvas to which this toolbar is attached.
    parent : QWidget, optional
        The parent widget of this toolbar (default is None).

    Methods
    -------
    handle_component(value)
        Handles the change in selected component and updates the display.
    """

    def __init__(self, canvas, parent=None):
        super().__init__(canvas, parent)
        self.parent = parent

        # Customize toolbar: remove unwanted buttons
        for action in self.actions():
            if action.text() in ['Subplots', 'Customize', 'Save', 'Back', 'Forward']:
                self.removeAction(action)

        #Â Add a spin box for selecting components in decomposition.
        self.addWidget(QLabel("Component :"))

        spin_box = QSpinBox(
            minimum=0, 
            maximum=len(self.parent.selected_object.factors.data) - 1, 
            value=self.parent.selected_object.selected_component
        )
        spin_box.setStatusTip("Choose the component to display")
        spin_box.valueChanged.connect(self.handle_component)
        self.addWidget(spin_box)

        # Set the background color of the toolbar to transparent.
        self.setStyleSheet("background-color: transparent;")

    def handle_component(self, value):
        """
        Handles the selection of a component and updates the current widget.

        Parameters
        ----------
        value : Any
            The value representing the selected component.
        """

        modified_object = self.parent.GraphTab.currentWidget().child_object
        modified_object.selected_component = value
        self.parent.GraphTab.currentWidget().update()


class x_GraphTabWidget(QWidget):
    """
    A custom QWidget for displaying graph tabs with factors and loadings plots.

    Parameters
    ----------
    key : str
        A unique identifier for the widget.
    parent : QWidget
        The parent widget.
    parent_object : object
        An object containing the data and settings for the plots.
    child_object : object
        An object containing the selected component and its data.

    Attributes
    ----------
    key : str
        A unique identifier for the widget.
    parent : QWidget
        The parent widget.
    parent_object : object
        An object containing the data and settings for the plots.
    child_object : object
        An object containing the selected component and its data.
    layout : QVBoxLayout
        The layout manager for the widget.
    x : list
        The x-axis values for the factors plot.
    fig : Figure
        The matplotlib figure object.
    factors_plot : Axes
        The axes for the factors plot.
    loadings_plot : Axes
        The axes for the loadings plot.
    canvas : FigureCanvas
        The canvas for rendering the matplotlib figure.
    toolbar : CustomToolbar
        The custom toolbar for the canvas.
        
    Methods
    -------
    update()
        Updates the plots with the current data.
    """

    def __init__(self, key, parent, parent_object, child_object):
        super().__init__(parent)
        self.key = key
        self.parent = parent
        self.parent_object = parent_object
        self.child_object = child_object

        # Layout for the widget
        self.layout = QVBoxLayout(self)
        self.layout.setAlignment(Qt.AlignTop)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(0)

        # Number is the selected component in the decomposition.
        number = self.child_object.selected_component

        # Retrieve the axis parameters for the plots.
        self.x = [
            self.parent_object.Energy_offset + i * self.parent_object.Scales[2] 
            for i in range(len(self.child_object.factors.data[number]))
        ]

        # Create the figure and subplots for the factors and loadings.
        self.fig, (self.factors_plot, self.loadings_plot) = plt.subplots(1, 2, width_ratios=[2, 1])
        self.fig.patch.set_alpha(0.0)

        self.canvas = FigureCanvas(self.fig)
        self.canvas.setStyleSheet("background-color: transparent;")
        self.canvas.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.layout.addWidget(self.canvas)

        self.update()

        # Add custom toolbar (with component selection) to the canvas.
        self.toolbar = CustomToolbar(self.canvas, self.parent)
        self.layout.addWidget(self.toolbar)

    def update(self):
        """
        Updates the plots for factors and loadings based on the selected component.
        This method clears the current plots and updates them with the data from the
        selected component of the child object. It sets the x-axis limits, labels,
        titles, and grid for the factors plot, and sets the title for the loadings
        plot. It also adjusts the layout and redraws the canvas.
        """

        number = self.child_object.selected_component

        self.factors_plot.clear()
        self.loadings_plot.clear()

        self.factors_plot.plot(self.x, self.child_object.factors.data[number])
        self.loadings_plot.imshow(self.child_object.loadings.data[number], cmap='inferno')

        # Energies higher than 10 keV are not relevant for the factors plot.
        self.factors_plot.set_xlim((0, 10))
        self.factors_plot.set_xlabel('Energy (keV)', color='white')
        self.factors_plot.set_ylabel('Intensity', color='white')
        self.factors_plot.set_title('Factors', color='white')
        self.factors_plot.grid()

        self.loadings_plot.set_title('Loadings', color='white')

        self.factors_plot.tick_params(color='white', labelcolor='white')
        self.loadings_plot.tick_params(color='white', labelcolor='white')

        plt.subplots_adjust(bottom=0.2)
        self.fig.tight_layout()

        # Draw in the GUI.
        self.canvas.draw()


class x_QVBoxLayout(QVBoxLayout):
    """
    A custom QVBoxLayout class that supports context management and 
    layout ratio.

    Parameters
    ----------
    parent : QWidget or QLayout
        The parent widget or layout to which this layout will be added.
    name : str
        A unique name for this layout, used to generate a key.
    ratio : int, optional
        The ratio for adding this layout to its parent, by default 1.

    Attributes
    ----------
    parent : QWidget or QLayout
        The parent widget or layout.
    ratio : int
        The ratio for adding this layout to its parent.
    key : str
        A unique key generated from the parent's key and the provided name.

    Methods
    -------
    __enter__()
        Sets the layout for the parent widget or adds it to the parent layout.
    __exit__(*args)
        Placeholder for context management exit, does nothing.
    """

    def __init__(self, parent, name, ratio=1):
        super().__init__()
        self.parent = parent
        self.ratio = ratio

        try:
            self.key = self.parent.key + f'_{name}'
        except AttributeError:
            self.key = name

    def __enter__(self):
        if isinstance(self.parent, QWidget):
            self.parent.setLayout(self)
        else:
            self.parent.addLayout(self, self.ratio)
        return self

    def __exit__(self, *args):
        pass


class x_QHBoxLayout(QHBoxLayout):
    """
    A custom QHBoxLayout class that supports context management and 
    automatic key generation.

    Parameters
    ----------
    parent : QWidget or QLayout
        The parent widget or layout.
    name : str
        The name to be appended to the parent's key or used as the key.

    Attributes
    ----------
    parent : QWidget or QLayout
        The parent widget or layout.
    key : str
        The generated key based on the parent's key and the provided name.

    Methods
    -------
    __enter__()
        Sets the layout for the parent widget or adds the layout to the 
        parent layout.
    __exit__(*args)
        Placeholder for context management exit.
    """

    def __init__(self, parent, name):
        super().__init__()
        self.parent = parent

        try:
            self.key = self.parent.key + f'{name}'
        except AttributeError:
            self.key = name

    def __enter__(self):
        if isinstance(self.parent, QWidget):
            self.parent.setLayout(self)
        else:
            self.parent.addLayout(self, 1)
        return self

    def __exit__(self, *args):
        pass


class x_QLabel:
    """
    A custom QLabel wrapper class.

    Parameters
    ----------
    parent : QWidget
        The parent widget to which this label belongs.
    label : str, optional
        The text to be displayed on the label (default is an empty string).
    alignment : Qt.Alignment, optional
        The alignment of the label text (default is Qt.AlignLeft).
        
    Attributes
    ----------
    parent : QWidget
        The parent widget.
    label : QLabel
        The QLabel instance with the specified text and alignment.

    Methods
    -------
    __init__(parent, label='', alignment=Qt.AlignLeft)
        Initialises the x_QLabel instance and adds it to the parent's layout.
    """

    def __init__(self, parent, label='', alignment=Qt.AlignLeft):
        self.parent = parent
        self.label = QLabel(label)
        self.label.setAlignment(alignment)

        try:
            self.parent.layout.addWidget(self.label)
        except AttributeError:
            self.parent.addWidget(self.label)


class x_QImage_Label(QLabel):
    """
    A custom QLabel widget for displaying and interacting with images.

    Parameters
    ----------
    parent : QWidget
        The parent widget.
    signals : dict
        A dictionary of signals for communication.
    signal : str, optional
        The signal key for updating the combobox (default is '').
    coord_label : QLabel, optional
        A label for displaying coordinates (default is None).
    title_input : QLineEdit, optional
        An input for the title (default is None).

    Attributes
    ----------
    parent : QWidget
        The parent widget.
    layout : QHBoxLayout
        The layout for the widget.
    coord_label : QLabel
        A label for displaying coordinates.
    title_input : QLineEdit
        An input for the title.
    title : str
        The title of the image.
    pixmap : QPixmap
        The pixmap of the image.
    image : ndarray
        The image data.
    pixmap_offset : tuple
        The offset of the pixmap.
    pixel_size : int
        The size of each pixel.
    min_img_x : float
        The minimum x-coordinate of the image.
    min_img_y : float
        The minimum y-coordinate of the image.
    max_img_x : float
        The maximum x-coordinate of the image.
    max_img_y : float
        The maximum y-coordinate of the image.
    signals : dict
        A dictionary of signals for communication.
    signal : pyqtSignal
        The signal for updating the image.

    Methods
    -------
    update(image, colorscale='Greyscale')
        Updates the displayed image with the given colourscale.
    set_pixmap_params(image, offset, pixel_size, min_img_x, min_img_y, max_img_x, max_img_y)
        Sets the parameters for the pixmap.
    mousePressEvent(event)
        Handles mouse press events.
    mouseMoveEvent(event)
        Handles mouse move events.
    enterEvent(event)
        Handles the cursor when entering the widget.
    leaveEvent(event)
        Handles the cursor when leaving the widget.
    """

    def __init__(self, parent, signals, signal='', coord_label=None, title_input=None):
        super().__init__()
        self.parent = parent
        self.layout = QHBoxLayout()
        self.parent.addLayout(self.layout)

        # Label to disply pointed coordinates.
        self.coord_label = coord_label
        # Line edit to set the title (defined outside this label).
        self.title_input = title_input

        self.setAlignment(Qt.AlignCenter)
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.setMouseTracking(True)
        self.title = ""

        # Initialize image parameters for further definition.
        self.pixmap = None
        self.image = None
        self.pixmap_offset = (0, 0)
        self.pixel_size = 1
        self.min_img_x, self.min_img_y = np.inf, np.inf
        self.max_img_x, self.max_img_y = -np.inf, -np.inf

        self.signals = signals

        if signal != '':
            self.signal = self.signals[signal]  # Signal for updating the image
            self.signal.connect(self.update)

        self.layout.addWidget(self)

    def update(self, image, colorscale='Greyscale'):
        """
        Update the display with a new image and apply a colourscale.

        Parameters
        ----------
        image : numpy.ndarray or str
            The image to be displayed. If a string is provided, the function 
            returns without updating.
        colorscale : str, optional
            The colourscale to be applied to the image. Default is 'Greyscale'.
        """

        if isinstance(image, str):
            return

        # Create a Pixmap object.
        self.setPixmap(QPixmap())

        ## --- Keep the image in the layout --- ##
        height, width = image.shape[0], image.shape[1]
        image_min, image_max = image.min(), image.max()

        pixel_size = min(self.height() // height, self.width() // width)

        start_x, start_y = (self.width() - pixel_size * width) // 2, (self.height() - pixel_size * height) // 2
        ## ------------------------------------ ##

        pixmap = QPixmap(self.width(), self.height())
        pixmap.fill(Qt.transparent)

        painter = QPainter(pixmap)
        pen = QPen()
        pen.setWidth(pixel_size)

        colorscale = colorscales.cs.get(colorscale)(width * height)

        # Draw the image with the selected colourscale.
        for x in range(width):
            for y in range(height):
                color = image[y, x]
                index = max(int(((width * height) / 100) * float((100 * (color - image_min)) / (image_max - image_min))) - 1, 0)
                color = QColor(colorscale[index][0], colorscale[index][1], colorscale[index][2])
                pen.setColor(color)
                painter.setPen(pen)
                painter.drawPoint(start_x + x * pixel_size + pixel_size / 2, start_y + y * pixel_size + pixel_size / 2)

        painter.end()

        self.pixmap = pixmap
        self.setPixmap(self.pixmap)
        self.setText("")

        # Update image parameters
        self.set_pixmap_params(image, (start_x + pixel_size / 2, start_y + pixel_size / 2), pixel_size, 0, 0, height - 1, width - 1)

    def set_pixmap_params(self, image, offset, pixel_size, min_img_x, min_img_y, max_img_x, max_img_y):
        """
        Set parameters for the pixmap.

        Parameters
        ----------
        image : QImage
            The image to be used for the pixmap.
        offset : QPoint
            The offset position of the pixmap.
        pixel_size : int
            The size of each pixel in the pixmap.
        min_img_x : int
            The minimum x-coordinate of the image.
        min_img_y : int
            The minimum y-coordinate of the image.
        max_img_x : int
            The maximum x-coordinate of the image.
        max_img_y : int
            The maximum y-coordinate of the image.
        """

        # Used for getting the image value at the mouse position.
        self.image = image
        self.pixmap_offset = offset
        self.pixel_size = pixel_size
        self.min_img_x, self.min_img_y = min_img_x, min_img_y
        self.max_img_x, self.max_img_y = max_img_x, max_img_y

    def mouseMoveEvent(self, event: QMouseEvent):
        """
        Handle the mouse move event to update the coordinate label with the 
        current mouse position and corresponding image value.

        Parameters
        ----------
        event : QMouseEvent
            The mouse event containing the current position of the mouse cursor.
        """

        pos = event.position().toPoint()
        img_x = (pos.x() - self.pixmap_offset[0] + self.pixel_size // 2) // self.pixel_size
        img_y = (pos.y() - self.pixmap_offset[1] + self.pixel_size // 2) // self.pixel_size

        if self.coord_label and self.max_img_x >= img_x >= self.min_img_x and self.max_img_y >= img_y >= self.min_img_y:
            self.coord_label.label.setText(
                f"{self.title_input.line_edit.text()} ({img_x}, {img_y})) - Value : {self.image[int(img_y), int(img_x)]}"
            )
        else:
            self.coord_label.label.setText(
                f"{self.title_input.line_edit.text()}"
            )

    def enterEvent(self, event):
        """
        Handles the event when the cursor enters the specific area.
        """

        self.setCursor(Qt.CrossCursor)

    def leaveEvent(self, event):
        """
        Handles the event when the cursor leaves the specific area.
        """

        self.setCursor(Qt.ArrowCursor)


class x_QTabWidget(QTabWidget):
    """
    A custom QTabWidget with additional functionality.

    Parameters
    ----------
    parent : QWidget
        The parent widget.
    name : str
        The name of the tab widget.
    movable : bool, optional
        If True, tabs can be moved by the user (default is False).
    closable : bool, optional
        If True, tabs can be closed by the user (default is False).

    Attributes
    ----------
    name : str
        The name of the tab widget.
    parent : QWidget
        The parent widget.
    key : str
        A unique key for the tab widget, combining the parent's key and name.

    Methods
    -------
    __enter__()
        Adds the widget to the parent when used in a context manager.
    __exit__(*args)
        Placeholder for context manager exit, does nothing.
    """

    def __init__(self, parent, name, movable=False, closable=False):
        super().__init__()
        self.name = name
        self.parent = parent

        try:
            self.key = self.parent.key + f'_{name}'
        except AttributeError:
            self.key = name

        # Set the tab widget properties.
        self.setMovable(movable)
        self.setTabsClosable(closable)

        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

    def __enter__(self):
        self.parent.addWidget(self)
        return self

    def __exit__(self, *args):
        pass


class x_QTab(QWidget):
    """
    A custom QWidget class for creating a tab with a specific name and parent.

    Parameters
    ----------
    parent : QWidget
        The parent widget to which this tab belongs.
    name : str
        The name of the tab.

    Attributes
    ----------
    name : str
        The name of the tab.
    parent : QWidget
        The parent widget to which this tab belongs.
    key : str
        A unique key for the tab, derived from the parent's key and the tab's name.
    layout : QVBoxLayout
        The layout manager for the tab, aligned to the top.

    Methods
    -------
    __enter__()
        Adds the tab to the parent widget.
    __exit__(*args)
        Placeholder for context manager exit, does nothing.
    """


    def __init__(self, parent, name):
        super().__init__()
        self.name = name
        self.parent = parent
        self.key = self.parent.key + f'_{name}'

        # Add a layout for the tab.
        self.layout = QVBoxLayout(self)
        self.layout.setAlignment(Qt.AlignTop)

    def __enter__(self):
        self.parent.addTab(self, self.name)
        return self

    def __exit__(self, *args):
        pass


class x_QPushButton:
    """
    A custom QPushButton class that integrates with a parent layout and 
    allows for additional configuration such as tooltips and labels.

    Parameters
    ----------
    parent : QWidget
        The parent widget to which this button belongs.
    name : str
        The name of the button.
    objects : list
        A list of objects associated with this button.
    tooltip : str, optional
        The tooltip text for the button (default is an empty string).
    label : str, optional
        The label text to be displayed alongside the button 
        (default is an empty string).

    Attributes
    ----------
    parent : QWidget
        The parent widget.
    name : str
        The name of the button.
    key : str
        A unique key generated by combining the parent's key and the 
        button's name.
    objects : list
        A list of objects associated with this button.
    layout : QHBoxLayout
        The horizontal box layout that contains the button and its label.
    button : QPushButton
        The QPushButton instance created by this class.
    """

    def __init__(self, parent, name, objects, tooltip='', label=''):
        self.parent = parent
        self.name = name
        self.key = self.parent.key + f'_{name}'
        self.objects = objects

        self.layout = QHBoxLayout()
        self.parent.layout.addLayout(self.layout)

        # If a label is provided, add it to the layout (before the button).
        if label != '':
            self.layout.addWidget(QLabel(label))

        self.button = QPushButton(name, self.parent)

        # If a tooltip is provided, set it for the button.
        if tooltip != '':
            self.button.setToolTip(tooltip)

        self.button.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)

        self.layout.addWidget(self.button)


class x_QComboBox:
    """
    A custom QComboBox widget with additional functionality for handling signals
    and updating items dynamically.

    Parameters
    ----------
    parent : QWidget
        The parent widget.
    name : str
        The name of the combobox.
    objects : object
        An object containing the items to be added to the combobox.
    signals : dict
        A dictionary of signals for the combobox.
    signal : str, optional
        The signal key for updating the combobox (default is '').
    tooltip : str, optional
        The tooltip text for the combobox (default is '').
    label : str, optional
        The label text to be displayed next to the combobox (default is '').

    Attributes
    ----------
    parent : QWidget
        The parent widget.
    name : str
        The name of the combobox.
    key : str
        A unique key for the combobox.
    objects : object
        An object containing the items to be added to the combobox.
    signals : dict
        A dictionary of signals for the combobox.
    signal : pyqtSignal
        The signal for updating the combobox.
    layout : QHBoxLayout
        The layout containing the combobox and optional label.
    combobox : QComboBox
        The combobox widget.

    Methods
    -------
    update(items)
        Updates the items in the combobox while preserving the current index.
    """

    def __init__(self, parent, name, objects, signals, signal='', tooltip='', label=''):
        self.parent = parent
        self.name = name
        self.key = self.parent.key + f'_{name}'
        self.objects = objects
        self.signals = signals

        if signal != '':
            self.signal = self.signals[signal]  # Signal for updating the combobox
            self.signal.connect(self.update)

        self.layout = QHBoxLayout()
        self.parent.layout.addLayout(self.layout)

        # If a label is provided, add it to the layout (before the combobox).
        if label != '':
            self.layout.addWidget(QLabel(label))

        self.combobox = QComboBox()

        # If a tooltip is provided, set it for the combobox.
        if tooltip != '':
            self.combobox.setToolTip(tooltip)

        # Add the items to the combobox, items correspond to the objects keys.
        self.combobox.addItems(self.objects.objects.keys())
        self.combobox.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)

        self.layout.addWidget(self.combobox)

    def update(self, items):
        """
        Updates the items in the combobox while preserving the current index.

        Parameters
        ----------
        items : list of str
            A list of new items to be added to the combobox.
        """

        # Clear the combobox and add the new items, keeping the current index selected.
        current_index = self.combobox.currentIndex()
        self.combobox.clear()
        self.combobox.addItems(items)

        try:
            self.combobox.setCurrentIndex(current_index)
        except IndexError:
            pass


class x_QLineEdit:
    """
    A custom QLineEdit widget with additional features.

    Parameters
    ----------
    parent : QWidget
        The parent widget.
    name : str
        The name of the QLineEdit widget.
    tooltip : str, optional
        The tooltip text for the QLineEdit widget (default is '').
    label : str, optional
        The label text to be displayed alongside the QLineEdit widget (default is '').
    placeholder : str, optional
        The placeholder text for the QLineEdit widget (default is '').
    default : str, optional
        The default text for the QLineEdit widget (default is '').

    Attributes
    ----------
    parent : QWidget
        The parent widget.
    name : str
        The name of the QLineEdit widget.
    key : str
        A unique key generated by combining the parent's key and the name.
    layout : QHBoxLayout
        The layout containing the QLineEdit and optional QLabel.
    line_edit : QLineEdit
        The QLineEdit widget.
    """


    def __init__(self, parent, name, tooltip='', label='', placeholder='', default=''):
        self.parent = parent
        self.name = name
        self.key = self.parent.key + f'_{name}'

        self.layout = QHBoxLayout()
        self.parent.layout.addLayout(self.layout)

        # If a label is provided, add it to the layout (before the line edit).
        if label != '':
            self.layout.addWidget(QLabel(label))

        self.line_edit = QLineEdit()
        
        # If a tooltip is provided, set it for the line edit.
        if tooltip != '':
            self.line_edit.setToolTip(tooltip)

        self.line_edit.setPlaceholderText(placeholder) 
        self.line_edit.setText(default) # Set the default text for the line edit.
        self.line_edit.setMaxLength(60) # Set the maximum length of the input text.
        self.line_edit.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)

        self.layout.addWidget(self.line_edit)


class x_QTreeWidget:
    """
    A custom QTreeWidget class for managing and displaying hierarchical data.

    Parameters
    ----------
    parent : QWidget
        The parent widget.
    name : str
        The name of the tree widget.
    objects : object
        The object containing the data to be displayed.
    signals : dict
        A dictionary of signals for communication.
    window : QMainWindow
        The main window, used for displaying message boxes.
    columns : int, optional
        The number of columns in the tree widget (default is 1).
    headers : list of str, optional
        The headers for the columns (default is ['Column']).

    Methods
    -------
    __enter__()
        Enter the runtime context related to this object.
    __exit__(*args)
        Exit the runtime context related to this object.
    update()
        Update the tree widget with the current data.
    __context_menu(position)
        Display a context menu at the given position.
    """

    def __init__(self, parent, name, objects, signals, window, columns=1, headers=['Column']):
        self.parent = parent
        self.name = name
        self.key = self.parent.key + f'_{name}'
        self.objects = objects
        self.signals = signals
        self.window = window  # Main window, used for the message box

        self.signal = self.signals['signal_1']  # Signal for updating the tree
        self.signal.connect(self.update)

        self.tree = QTreeWidget()

        self.tree.setColumnCount(columns)
        self.tree.setHeaderLabels(headers)

        # Connect the context menu signal to the context menu function (right click).
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.__context_menu)

        # Enable sorting for the tree widget.
        self.tree.setSortingEnabled(True)

        self.parent.addWidget(self.tree)

    def __enter__(self):
        return self

    def __exit__(self, *args):
        pass

    def update(self):
        """
        Update the tree widget with the current objects and their sub-items.
        Clears the existing tree and repopulates it with the objects and their
        respective sub-items. Each item is made checkable and enabled. Emits a
        signal after updating the tree.
        """

        self.tree.clear()

        for obj in self.objects.objects.values():
            root_item = QTreeWidgetItem([obj.name, obj.signal_type, str(obj.size), obj.key])
            # Set the root item as checkable and enabled.
            root_item.setFlags(root_item.flags() | Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
            root_item.setCheckState(0, Qt.Unchecked)

            for sub_item in list(obj.sub_items.values()):
                child_item = QTreeWidgetItem([sub_item.name, '', '', sub_item.key])
                # Set the child item as unselectable.
                child_item.setFlags(child_item.flags() | Qt.ItemIsUserCheckable)
                root_item.addChild(child_item)

            self.tree.addTopLevelItem(root_item)

            # Update the combobox with the current objects.
            self.signals['signal_2'].emit(self.objects.objects.keys(), None, None)

    def __context_menu(self, position):
        """
        Display a context menu at the given position in the tree view.

        Parameters
        ----------
        position : QPoint
            The position of the selected object to display metadata.

        Notes
        -----
        This method creates a context menu with an option to show metadata for the 
        selected item. If the selected item has no parent and the "Show metadata" 
        action is triggered, it retrieves and displays the metadata of the object 
        associated with the selected item.
        """

        item = self.tree.itemAt(position)

        if item and not item.parent():
            # Create a context menu with an action to show metadata.
            context_menu = QMenu(self.window)
            show_metadata_action = context_menu.addAction("Show metadata")

            action = context_menu.exec(self.tree.viewport().mapToGlobal(position))

            if action == show_metadata_action:
                object_name = item.text(0)
                if object_name in self.objects.objects:
                    # Display the formated metadata of the selected object.
                    metadata = self.objects[object_name].metadata
                    metadata_str = str(metadata).replace('{', '').replace('}', '').replace('\'', '').replace(',', '\n')
                    show_message("Metadata", metadata_str, 'info')


class x_QSeparator(QFrame):
    """
    A custom QFrame separator widget.
    Parameters
    ----------
    window : QWidget
        The parent window for the separator.
    parent : QBoxLayout
        The layout to which the separator will be added.
    orientation : str, optional
        The orientation of the separator, either 'H' for horizontal or 'V' 
        for vertical. Default is 'H'.

    Methods
    -------
    __init__(window, parent, orientation='H')
        Initializes the separator with the given orientation and adds it to 
        the parent layout.
    """

    def __init__(self, window, parent, orientation='H'):
        super().__init__(window)
        self.setFrameShape(QFrame.HLine if orientation == 'H' else QFrame.VLine)
        self.setFrameShadow(QFrame.Sunken)
        parent.addWidget(self)
